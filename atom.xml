<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liang&#39;s Blog</title>
  
  
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="http://stardustdl.github.io/Blog/"/>
  <updated>2017-12-25T13:32:31.508Z</updated>
  <id>http://stardustdl.github.io/Blog/</id>
  
  <author>
    <name>Stardust D.L.</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C程序设计语言</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/25/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/25/C程序设计语言/</id>
    <published>2017-12-25T11:26:43.000Z</published>
    <updated>2017-12-25T13:32:31.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>书籍名：《C程序设计语言（第二版）》</p></blockquote><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><ul><li>枚举 <code>enum id{A=1,B=2,...}</code></li><li>字符串支持连接 <code>&quot;abc&quot; &quot;def&quot;=&quot;abcdef&quot;</code></li><li><code>ctype</code> 中的函数与字符表无关</li><li>使用 <code>unsigned</code> 的变量在隐式转换时和具体实现有关要十分注意，可能不是预期的。</li><li>float 不会自动提升为 double</li><li><p>伪随机数算法 $[0,32767]$ 的伪随机整数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> _next=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rand</span><span class="params">()</span></span>&#123;</span><br><span class="line">    _next=_next*<span class="number">1103515245</span>+<span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(_next/<span class="number">65536</span>)%<span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>&#123;_next=seed;&#125;</span><br></pre></td></tr></table></figure></li><li><p>逗号表达式从左到右求值，最右侧的表达式为其结果值。函数参数中的逗号不是逗号表达式，C语言没有定义其运算顺序</p></li><li>对于一个运算，左右表达式的运算先后是不确定的。</li></ul><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><ul><li>Shell-Sort<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span> v[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap=n&gt;&gt;<span class="number">1</span>;gap;gap&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=gap;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i-gap;j&gt;=<span class="number">0</span> &amp;&amp; v[j]&gt;v[j+gap];j-=gap)</span><br><span class="line">                swap(v[j],v[j+gap]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><ul><li>external,internal 关键字修饰变量</li><li>register 关键字，寄存器变量地址不可访问</li><li>static 关键字修饰全局变量，使变量限定在当前编译文件中<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2></li></ul><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><ul><li>行末使用 <code>\</code> 使用多行定义</li><li><code>undef</code> 取消宏定义</li><li>替换文本中 <code>#</code>加在参数名前，则将会生成和参数书写完全相同的字符串<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(expr) printf(#expr <span class="meta-string">" = %g\n"</span>,expr)</span></span><br><span class="line">``` </span><br><span class="line">+ `##` 运算符</span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> paste(a,b) a ## b</span></span><br><span class="line">paste(name,<span class="number">1</span>) =&gt; name1</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li><code>#if</code></li><li><code>#endif</code></li><li><code>#elif</code></li><li><code>#else</code></li><li><code>#ifdef = #if defined id</code></li><li><code>#ifndef = #if !defined id</code></li><li><code>#line constval [&quot;filename&quot;]</code></li><li><code>#error ...</code></li><li><code>#praga ...</code></li></ul><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><ul><li><code>void*</code> 作为通用指针</li><li>指针实现数组一般快于下标实现数组</li><li>指针支持和整数加减，与指针相减和比较运算（位置比较）</li><li><p>数组和指针不完全等价，数组本身不可变，但指针可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* s,<span class="keyword">char</span> *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*s++=*t++);</span><br><span class="line">&#125;</span><br><span class="line">*p++=val;<span class="comment">//push</span></span><br><span class="line">val=*--p;<span class="comment">//pop</span></span><br></pre></td></tr></table></figure></li><li><p>以下表达等价</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">13</span>])</span><br><span class="line">f(<span class="keyword">int</span> c[][<span class="number">13</span>])</span><br><span class="line">f(<span class="keyword">int</span> (*c)[<span class="number">13</span>])</span><br></pre></td></tr></table></figure></li></ul><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><ul><li><code>union</code> 类型：同一起点，不同类型变量，自动对齐，只能对第一个元素初始化</li><li>位字段：二进制标志位集合，后面的数字指定位长，仅能使用 <code>int</code>，不支持 <code>&amp;</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b:<span class="number">1</span>;</span><br><span class="line">&#125;flgs;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><ul><li><code>exit(exitcode)</code> </li><li><code>printf</code> 函数格式化：<code>%?</code> <code>?</code> 表示转换说明<ul><li><code>-</code> 左对齐</li><li>数字 最小字段宽度或精度</li><li><code>.</code> 用于区分最小字段宽度和精度</li><li><code>h/l</code> 整数作为 <code>short/long</code></li><li><code>d/i</code> 十进制整数</li><li><code>o</code> 无符号八进制整数</li><li><code>x/X</code> 无符号十六进制整数，指定大小写</li><li><code>u</code> 无符号十进制整数</li><li><code>c</code> 字符</li><li><code>f</code> double 十进制小数</li><li><code>e/E</code> double 十进制小数 科学记数法</li><li><code>g/G</code> double 十进制小数 根据指数决定使用哪一种表示方式</li><li><code>p</code> void* 类型</li><li>使用 <code>*</code> 指定宽度或精度，将使用下一参数（int）得到</li></ul></li><li><p>变长参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> *a,...)</span></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,fmt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span>* p=fmt;*p;p++)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>scanf</code> 函数 返回成功赋值的个数，文件结尾返回 <code>EOF</code></p></li></ul><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=fopen(name,mode=<span class="string">"r[+]"</span>,<span class="string">"w[+]"</span>,<span class="string">"a[+]"</span>[,<span class="string">"b"</span>])</span><br><span class="line"><span class="comment">//以下是宏而不是函数</span></span><br><span class="line"><span class="keyword">int</span> getc(FILE *fp);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c,FILE* fp)</span></span>=c;</span><br><span class="line"><span class="built_in">fscanf</span>(FILE* fp,...)</span><br><span class="line"><span class="built_in">fprintf</span>(FILE* fp,...)</span><br><span class="line"><span class="comment">//清空缓冲区并关闭文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *fp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>*line,<span class="keyword">int</span> maxvalue,FILE *fp)</span></span>=success? line:<span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fputs</span><span class="params">(<span class="keyword">char</span>*line,FILE *fp)</span></span>=success? line:EOF;</span><br><span class="line">fgetc,fputc</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c,FILE *fp)</span></span>=success?c:EOF; <span class="comment">//写回一个字符，只能接受一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>;<span class="comment">//删除文件，成功返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>;<span class="comment">//重命名文件，成功返回0</span></span><br><span class="line"><span class="function">FILE* <span class="title">tmpfile</span><span class="params">()</span></span>;<span class="comment">//wb+创建临时文件</span></span><br></pre></td></tr></table></figure><ul><li><code>size_t fread(void*ptr,size_t size,size_t nobj,FILE *stream)</code> 读取最多nobj个长度为size的对象，并保存到ptr数组中，返回读取到的个数。</li><li><code>size_t fwrite(const void*ptr,size_t size,size_t nobj,FILE *stream)</code> 从ptr数组读取nobj个长度为size的对象，并输出，返回输出的个数。</li><li><code>int fseek(FILE* stream, long offset,int origin)</code><br>从origin偏移offset个位置。origin=SEEK_SET,SEEK_CUR,SEEK_END，文本流只能是offest只能是0或ftell得到的值。</li><li><code>long ftell(FILE *stream)</code> 得到当前位置，错误返回-1L</li><li><code>void rewind(FILE *stream)</code> 回到起点，清除错误状态</li><li><code>int fgetpos(FILE *stream,fpos_t *pos)</code> 记录当前位置到pos</li><li><code>int fsetpos(FILE *stream,const fpos_t *pos)</code></li><li>标准文件指针 <code>stdin,stdout,stderr</code></li></ul><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul><li><code>strcat(s,t)</code></li><li><code>strncat(s,t,n)</code></li><li><code>strcmp(s,t)</code></li><li><code>strncmp(s,t,n)</code></li><li><code>strcpy(s,t)</code></li><li><code>strncpy(s,t,n)</code></li><li><code>strlen(s)</code></li><li><code>strchr(s,c)</code> 正向查找，返回指针</li><li><code>strrchr(s,c)</code> 反向查找，返回指针</li><li><code>memcpy(s,t,n)</code></li><li><code>memmove(s,t,n)</code></li><li><code>memcmp(s,t,n)</code></li><li><code>memchr(s,c,n)</code></li><li><code>memset(s,c,n)</code></li></ul><h2 id="更多函数"><a href="#更多函数" class="headerlink" title="更多函数"></a>更多函数</h2><ul><li><code>void* malloc(size_t n)</code> n字节长度</li><li><code>void* calloc(size_t n,size_t size)</code> n个指定字节长度元素的空间</li><li><code>free(p)</code> 仅限使用上面两个函数申请的空间</li><li><code>ldexp(x,n)</code> $=x*2^n$</li><li><code>frexp(x,int* exp)</code> $x=a*2^n$，其中 $a \in [1/2,1]$，返回a，exp=n</li><li><code>modf(x,double *ip)</code> 返回小数部分，ip=整数部分，符号均和x相同</li><li><code>fmod(x,y)</code> 浮点余数</li><li><code>double atof(char*)</code></li><li><code>int atoi(char*)</code></li><li><code>long atol(char*)</code></li><li><code>abort()</code></li><li><code>ateexit(void (*func)(void))</code> 登记一个程序正常终止时调用的函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;书籍名：《C程序设计语言（第二版）》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;枚举 &lt;cod
      
    
    </summary>
    
      <category term="Readings" scheme="http://stardustdl.github.io/Blog/categories/Readings/"/>
    
    
      <category term="CS" scheme="http://stardustdl.github.io/Blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>iExpr 反馈收集</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/25/iExpr-%E5%8F%8D%E9%A6%88%E6%94%B6%E9%9B%86/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/25/iExpr-反馈收集/</id>
    <published>2017-12-25T01:33:34.000Z</published>
    <updated>2017-12-25T01:36:53.595Z</updated>
    
    <content type="html"><![CDATA[<p>请在评论区留下建议和反馈，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请在评论区留下建议和反馈，谢谢。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Designs" scheme="http://stardustdl.github.io/Blog/categories/Designs/"/>
    
    
  </entry>
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/24/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/24/牛顿迭代法/</id>
    <published>2017-12-24T12:35:05.000Z</published>
    <updated>2017-12-24T12:53:44.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>伽罗瓦云：五次及以上多项式方程没有根式解。但面对生活中求解各种复杂方程的真实需求，是否束手无策？非也，今用牛顿迭代法高效求解方程的近似根。本文介绍了牛顿迭代法的推导和其计算机实现，并使用牛顿迭代法实现了开方等运算。</p></blockquote><h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>我们已知：微分是曲线的线性逼近。<br>对于二阶连续可导函数 $y=f(x)$ ，设 $r$是 $f(x)=0$ 的根。对曲线上的任意一点 $A(x_0,y_0)$<br>，作微分 $y’=f’(x) \text{d}x$, 交 $x$ 轴于一点 $(x_1,0)$ ，如下图所示，称 $x_1$ 为 $r$ 的一次近似值。</p><p><img src="http://osyor26xu.bkt.clouddn.com/math2.png" alt=""></p><p>注意到$x_1$与函数的零点仍有一段距离，<br>过 $x_1$ 作 $x$ 轴垂线，<br>交 $y=f(x)$ 于$B(x_1,y_1)$ ，<br>继续作微分 $y’=f’(x_1)\text{d}x$ ，<br>交 $x$ 轴于 $(x_2,0)$ ，<br>称 $x_2$ 为 $r$ 的二次近似值。<br>如下图，此时 $x_2$ 与 $r$ 更加接近。</p><p><img src="http://osyor26xu.bkt.clouddn.com/math3.png" alt=""></p><p>重复上述过程，经过50次迭代，得下图. 此时第50次近似值已经十分接近 $r$ 。</p><p><img src="http://osyor26xu.bkt.clouddn.com/math4.png" alt=""></p><p><strong>定义</strong>：<br>设二阶连续可导函数 $y=f(x)$，$r$ 是 $f(x)=0$ 的根，选取 $x_0$ 作为 $r$ 的初始近似值，过点 $(x_0,f(x_0))$ 做曲线 $y=f(x)$ 的微分 $L$, 求出 $L$ 与 $x$ 轴交点的横坐标 $x_1=x_0-\frac{f(x_0)}{f’(x_0)}$，称 $x_1$ 为 $r$ 的一次近似值。过点$(x_1,f(x_1))$ 做曲线 $y=f(x)$ 的切线，并求该切线与x轴交点的横坐标 $x_2=x_1-\frac{f(x_1)}{f’(x_1)}$，称 $x_2$ 为 $r$ 的二次近似值。重复以上过程，得 $r$ 的近似值序列，其中 $x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$ ，称为 $r$ 的 $n+1$ 次近似值，上式称为 <strong>牛顿迭代序列</strong>。</p><h2 id="收敛条件"><a href="#收敛条件" class="headerlink" title="收敛条件"></a>收敛条件</h2><p>关于牛顿法的局部收敛性，我们有如下定理：</p><p><strong>定理</strong>：设 $x^*$ 是方程 $f(x)=0$ 的根，$f$ 在某个包含 $x^*$ 为内点的区间内足够光滑，且 $f’(x) \ne 0$。那么存在 $x^*$ 的一个邻域 $N(x^*)=[x^*-\delta,x^*+\delta]$，使得对于任意 $x_0 \in N(x^*)$，牛顿法产生的迭代序列以不低于二阶的收敛速度收敛于解 $x^*$。</p><p><strong>证明</strong>：<br>牛顿法是对应于函数 $\phi(x)=x-\frac{f(x)}{f’(x)}$ 的不动点迭代。我们有</p><script type="math/tex; mode=display">\phi'(x)=\frac{f(x)f''(x)}{[f'(x)]^2}</script><p>若 $f’(x)\ne 0$，则有 $\phi’(x^*)=0$。因此，牛顿迭代法是局部收敛的。</p><p>和不动点收敛类似，对于牛顿法迭代，我们有</p><script type="math/tex; mode=display">x_{k+1}-x^*=\phi(x_k)-\phi(x^*)=\phi(x^*)+\phi'(x^*)(x_k-x^*)+\frac{\phi''(\xi_k)}{2}(x_k-x^*)^2-\phi(x^*)</script><script type="math/tex; mode=display">=\frac{\phi''(\xi_k)}{2}(x_k-x^*)^2</script><p>式中，$\xi_k$ 位于 $x_k$ 和 $x^*$ 之间。因此</p><script type="math/tex; mode=display">\lim_{k\rightarrow +\infty} \frac{|x_{k+1}-x^*|}{|x_k-x^*|^2}=\lim_{k \rightarrow + \infty} \frac{|\phi''(\xi_k)|}{2}= \frac{|\phi''(x^*)|}{2}</script><h1 id="计算机实现"><a href="#计算机实现" class="headerlink" title="计算机实现"></a>计算机实现</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>首先我们的目标是近似求解函数的根。<br>由于牛顿迭代法迭代过程只限于一阶导数，<br>我们可以使用差分的方式来近似计算某点导数值：</p><script type="math/tex; mode=display">f'(x)=\frac{f(x+eps)-f(x)}{eps}</script><p>其中的 $eps$ 取决于我们对最终解精度的要求。</p><p>进而，我们由上一节中牛顿迭代公式有：</p><script type="math/tex; mode=display">x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}</script><p>注意到 $\lim_{n \rightarrow +\infty} f(x_n)=0$ ，<br>迭代最终收敛，则当我们迭代到 $|f(x_n)|&lt;eps$ 时就可以退出迭代，<br>此时的 $x_n$ 即为近似解。</p><p><strong>注</strong>：在由于计算机内部对实数的存储是有误差的，所以对于 $\epsilon$ 的选取应格外小心。</p><h2 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff</span><span class="params">(f,x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (f(x+eps)-f(x))/eps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getZero</span><span class="params">(f,x0)</span>:</span></span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    s=x0</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        s=s-f(s)/diff(f,s)</span><br><span class="line">        n=n+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> math.fabs(f(s))&lt;eps:</span><br><span class="line">            <span class="keyword">return</span> (s,n)</span><br></pre></td></tr></table></figure><ul><li>$getZero(f,x_0)$ 函数接受一个函数 $f$ ，和迭代起点 $x_0$</li><li>$\epsilon$ 即 $eps$ 为解的精度</li><li>$n$ 为迭代次数</li><li>$s$ 为最终的解值</li></ul><h2 id="使用计算机求平方根"><a href="#使用计算机求平方根" class="headerlink" title="使用计算机求平方根"></a>使用计算机求平方根</h2><p>我们可以使用上面的代码求解平方根。<br>首先求解平方根即求函数 $f(x)=x^2-a$ 的零点。</p><p>调用以上函数即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="keyword">lambda</span> x: x**<span class="number">2</span>-a</span><br><span class="line">x, n=getZero(f,x0)</span><br><span class="line">print(x,n,f(x))</span><br></pre></td></tr></table></figure><p>我们取 $\epsilon=10^{-15},a=2,x_0=10$ 时，程序输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.4142135623730951 18 4.440892098500626e-16</span><br></pre></td></tr></table></figure><p>说明我们得到的近似解为 $\sqrt{2} \approx 1.4142135623730951$ ，迭代了 $18$ 次，<br>此处的 $f(x_n)=4.440892098500626*10^{-16}$，可见 $|f(x_n)|&lt;10^{-15}=\epsilon$，满足精度要求。</p><p>接下来我们使用系统自带的 求平方根函数 求值，其结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.4142135623730951</span><br></pre></td></tr></table></figure></p><p>由此可见我们使用牛顿迭代法求得的近似解已与系统提供的求根函数精度相等，能满足一般的需求。</p><h2 id="较复杂函数的零点近似求解"><a href="#较复杂函数的零点近似求解" class="headerlink" title="较复杂函数的零点近似求解"></a>较复杂函数的零点近似求解</h2><p>接下来以一个较复杂函数</p><script type="math/tex; mode=display">f(x)=\cos((2-\sin(x))^{\arctan(x)})</script><p>为例演示函数零点的求解过程。</p><p>此函数在 $x=0$ 附近的图像如下：<br><img src="http://osyor26xu.bkt.clouddn.com/math1.png" alt=""><br>为求出函数在 $x=2$ 附近的零点，<br>我们取 $\epsilon=10^{-10},x_0=2$ ，程序输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.567793875101797 5 -1.1263042511219229e-14</span><br></pre></td></tr></table></figure></p><p>则经过 $5$ 次迭代，我们得到近似解 $2.567793875101797$。</p><p>进一步的，我们可以通过其具体迭代过程发现，迭代的步长缩小得很快，这符合之前的预期：</p><script type="math/tex; mode=display">x_0=2</script><script type="math/tex; mode=display">x_1=3.048910600444615</script><script type="math/tex; mode=display">x_2=2.5508408648839507</script><script type="math/tex; mode=display">x_3=2.5679378839996416</script><script type="math/tex; mode=display">x_4=2.567793884737295</script><script type="math/tex; mode=display">x_5=2.567793875101797</script><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用牛顿迭代法，我们可以快速近似计算满足收敛条件的函数的零点。<br>这种方法解决了很多非线性方程组的求根问题，简化了许多工程问题的计算。</p><blockquote><p>参考资料：同济大学计算数学教研室《现代数值计算》（人民邮电出版社）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;伽罗瓦云：五次及以上多项式方程没有根式解。但面对生活中求解各种复杂方程的真实需求，是否束手无策？非也，今用牛顿迭代法高效求解方程的近似根。本文介绍了牛顿迭代法的推导和其计算机实现，并使用牛顿迭代法实现了开方等运算。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="Studies" scheme="http://stardustdl.github.io/Blog/categories/Studies/"/>
    
    
      <category term="CS" scheme="http://stardustdl.github.io/Blog/tags/CS/"/>
    
      <category term="Math" scheme="http://stardustdl.github.io/Blog/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>线性筛法及扩展</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/23/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E5%8F%8A%E6%89%A9%E5%B1%95/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/23/线性筛法及扩展/</id>
    <published>2017-12-23T12:32:06.000Z</published>
    <updated>2017-12-23T13:26:49.910Z</updated>
    
    <content type="html"><![CDATA[<p>以下代码中的定义：</p><ul><li>mindiv[i]: i的最小质因子</li><li>phi[i]: 欧拉函数i的值</li><li>mindivq[i]: i的最小质因子的个数</li><li>d[i]: i的约数个数</li><li>sumd[i]: i的约数和</li><li>miu[i]: 莫比乌斯函数i的值</li><li>inv[i]: i在mod n意义下的乘法逆元</li></ul><hr><h3 id="标准筛法"><a href="#标准筛法" class="headerlink" title="标准筛法"></a>标准筛法</h3><p>欧拉筛法，可以保证每个数只被自己最小的质因子筛去，时间复杂度O(n)<br>两种等价实现<br>易于理解版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mindiv[i])</span><br><span class="line">mindiv[i]=pris[++cnt]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123;</span><br><span class="line">mindiv[k]=pris[j];</span><br><span class="line"><span class="keyword">if</span>(i%pris[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又短又快版（避免了取模运算）：<strong>（待更新）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mindiv[i])</span><br><span class="line">mindiv[i]=pris[++cnt]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i%pris[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">mindiv[k]=pris[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展：求积性函数"><a href="#扩展：求积性函数" class="headerlink" title="扩展：求积性函数"></a>扩展：求积性函数</h3><p>积性函数定义：对于一个数论函数 $f(x)$，满足：若 $gcd(a,b)=1$ ，则 $f(a<em>b)=f(a)</em>f(b)$ 的函数 $f$ 。<br>由于这个性质，我们可以在筛法的同时求出积性函数的值<br>先看几个简单的积性函数：</p><h4 id="id函数"><a href="#id函数" class="headerlink" title="id函数"></a>id函数</h4><p>定义 $id(i)=i$ ，显然满足积性。<br>这就不用筛了，直接得到值</p><h4 id="e函数"><a href="#e函数" class="headerlink" title="e函数"></a>e函数</h4><p>又称单位函数，定义</p><script type="math/tex; mode=display">e(n)=\begin{cases}1, & \text{if $ n=1 $}\\0, & \text{otherwise}\end{cases}</script><h4 id="phi函数"><a href="#phi函数" class="headerlink" title="phi函数"></a>phi函数</h4><p>欧拉函数，很有用，可以用来求逆元。<br>定义 </p><script type="math/tex; mode=display">\phi(i)=\sum_{j=1}^ie(gcd(j,i))</script><p>即 $[1,n]$ 中，与 $n$ 互质的数的数量<br>易得对于质数，$phi(p)=p-1$，<br>对于合数有以下公式：</p><script type="math/tex; mode=display">n=\prod_{i=1}^r p_i^{q_i}</script><script type="math/tex; mode=display">\phi(n)=n*(1-1/p_1)*(1-1/p_2)*...</script><p>将n带入可得</p><script type="math/tex; mode=display">phi(n)=\prod_{i=1}^r(p_i-1)*p_i^{q_i-1}</script><p>这就很容易发现它的积性性质<br>用筛法怎么求呢？<br>稍微改一下就行了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mindiv[i])&#123;</span><br><span class="line">mindiv[i]=pris[++cnt]=i;</span><br><span class="line">phi[i]=i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123;</span><br><span class="line">mindiv[k]=pris[j];</span><br><span class="line"><span class="keyword">if</span>(i%pris[j]==<span class="number">0</span>)&#123;</span><br><span class="line">phi[k]=phi[i]*pris[j];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">phi[k]=phi[i]*(pris[j]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么呢？</p><ol><li>对于 <code>i%pris[j]!=0</code> 的项，它的最小质因子一定是 <code>pris[j]</code> ，则由积性函数性质可得 <code>phi[k]=phi[i]*phi[pris[j]]</code> ，其中<code>phi[pris[j]]=pris[j]-1</code></li><li>对于 <code>i%pris[j]==0</code> 的项，则说明 <code>pris[j]</code> 已经在 <code>i</code> 中已经出现了，而且是最小的，观察 $\phi$ 函数的计算式，可知此时应乘 <code>pris[j]</code></li></ol><h4 id="最小质因数的指数"><a href="#最小质因数的指数" class="headerlink" title="最小质因数的指数"></a>最小质因数的指数</h4><p>这个就很简单了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mindiv[i])&#123;</span><br><span class="line">mindiv[i]=pris[++cnt]=i;</span><br><span class="line">mindivq[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123;</span><br><span class="line">mindiv[k]=pris[j];</span><br><span class="line"><span class="keyword">if</span>(i%pris[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mindivq[k]=mindivq[i]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mindivq[k]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h4><p>首先约数个数如何求？</p><p>分解质因数，得到</p><script type="math/tex; mode=display">n=\prod_{i=1}^r p_i^{q_i}</script><p>则其 约数个数</p><script type="math/tex; mode=display">=\prod_{i=1}^r(qi+1)</script><p>这个结论由乘法原理易得，每个质因子有 $qi+1$ 种选法。<br>积性就不证了，比较显然。</p><p>怎么求呢？</p><p>观察筛法的过程， <code>i</code> 是质数时或 <code>i%pris[j]!=0</code> 时都比较容易，主要是 <code>i%pris[j]==0</code> 时需要考虑好。</p><p>下面来分析一下：</p><p>关键在于如何由 <code>d(i)</code> 转移到 <code>d(i*pris[j])</code><br>首先筛法保证了 <code>pris[j]</code> 一定是最小质因子，那么由于 <code>i%pris[j]==0</code> ，则意味着最小质因子的指数会 $+1$，这一点在上面的 <code>mindivq</code> 求解过程中也体现了。</p><p>$+1$ 会导致什么？</p><p>很自然会想到 </p><script type="math/tex; mode=display">d(k)=d(i)*\frac{(mindivq[k]=mindivq[i]+1)+1}{mindivq[i]+1}</script><p>就是这样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mindiv[i])&#123;</span><br><span class="line">mindiv[i]=pris[++cnt]=i;</span><br><span class="line">mindivq[i]=<span class="number">1</span>;</span><br><span class="line">d[i]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123;</span><br><span class="line">mindiv[k]=pris[j];</span><br><span class="line"><span class="keyword">if</span>(i%pris[j]==<span class="number">0</span>)&#123;</span><br><span class="line">mindivq[k]=mindivq[i]+<span class="number">1</span>;</span><br><span class="line">d[k]=d[i]/(mindivq[i]+<span class="number">1</span>)*(mindivq[k]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mindivq[k]=<span class="number">1</span>;</span><br><span class="line">d[k]=d[i]*d[pris[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="约数和"><a href="#约数和" class="headerlink" title="约数和"></a>约数和</h4><p>约数和又如何求？<br>分解质因数，得到</p><script type="math/tex; mode=display">n=\prod_{i=1}^r p_i^{q_i}</script><p>则其 约数和 </p><script type="math/tex; mode=display">=\prod_{i=1}^r\sum_{j=0}^{q_i} p_i^j</script><p>看起来也是比较显然，我们直接讨论如何利用筛法来求：</p><p>依然是利用和上面的类似思路：<br>只讨论 <code>i%pris[j]==0</code> 的情况：<br>需要除以 $\sum_{n=0}^{mindivq[i]}(pris[j])^n$<br>再乘以 $\sum_{n=0}^{mindivq[k]}(pris[j])^n$<br>其中 $mindivq[k]=mindiv[i]+1$<br>这样开两个辅助数组记录</p><script type="math/tex; mode=display">t1[i]=\sum_{n=0}^{mindivq[i]}pris[j]^n</script><script type="math/tex; mode=display">t2[i]=(mindiv[i])^{mindivq[i]}</script><p>就可以做了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mindiv[i])&#123;</span><br><span class="line">mindiv[i]=pris[++cnt]=i;</span><br><span class="line">sumd[i]=<span class="number">1</span>+i;</span><br><span class="line">t1[i]=<span class="number">1</span>+i;</span><br><span class="line">t2[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123;</span><br><span class="line">mindiv[k]=pris[j];</span><br><span class="line"><span class="keyword">if</span>(i%pris[j]==<span class="number">0</span>)&#123;</span><br><span class="line">t2[k]=t2[i]*pris[j];</span><br><span class="line">t1[k]=t1[i]+t2[k];</span><br><span class="line">sumd[k]=sumd[i]/t1[i]*t1[k];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sumd[k]=sumd[i]*sumd[pris[j]];</span><br><span class="line">t1[k]=<span class="number">1</span>+pris[j];</span><br><span class="line">t2[k]=pris[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="miu函数"><a href="#miu函数" class="headerlink" title="miu函数"></a>miu函数</h3><p>莫比乌斯函数，定义 </p><script type="math/tex; mode=display">\mu(n)=\begin{cases}1, & \text{if $ n=1 $}\\0, & \text{if $n$ is square free number}\\(-1)^{\text{质因数个数}}& \text{otherwise}\end{cases}</script><p>用筛法求也很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mindiv[i])&#123;</span><br><span class="line">mindiv[i]=pris[++cnt]=i;</span><br><span class="line">miu[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123;</span><br><span class="line">mindiv[k]=pris[j];</span><br><span class="line"><span class="keyword">if</span>(i%pris[j]==<span class="number">0</span>)&#123;</span><br><span class="line">miu[k]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">miu[k]=-miu[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h4><p>由求逆元的欧拉定理方法易知乘法逆元也是积性的，而且有一个很优美的性质：它是完全积性的。</p><p>所以求它变得很简单：</p><script type="math/tex; mode=display">inv[p]=p^{phi(n)-1}\mod n</script><script type="math/tex; mode=display">inv[k]=inv[i]*inv[pris[j]] \quad\text{if } gcd(k,n)=1</script><p>然而乘法逆元有一个递推的方法，更加简单：</p><p>首先逆元满足以下等式（定义）：</p><script type="math/tex; mode=display">inv[P\text{ mod }i]*(P\text{ mod }i)=1</script><p>将P % i展开：</p><script type="math/tex; mode=display">inv[P\text{ mod }i]*(P-\lfloor P/i \rfloor *i)=1</script><p>进一步展开：</p><script type="math/tex; mode=display">inv[P\text{ mod }i]*i*(-\lfloor P/i \rfloor)=1</script><p>会发现一个神奇的等式：</p><script type="math/tex; mode=display">i*(-\lfloor P/i \rfloor)*(inv[P\text{ mod }i])=1</script><p>此时 $(-\lfloor P/i \rfloor)*(inv[P\text{ mod }i])$ 就是 $i$ 的逆元！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>线性欧拉筛法简洁，积性函数性质优美，充分结合才能发挥更大的效果。同时又要注意到不同函数的性质，用筛法求积性函数的本质是根据积性函数的定义和运算式，利用筛法的特点，构造合适的转移方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下代码中的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mindiv[i]: i的最小质因子&lt;/li&gt;
&lt;li&gt;phi[i]: 欧拉函数i的值&lt;/li&gt;
&lt;li&gt;mindivq[i]: i的最小质因子的个数&lt;/li&gt;
&lt;li&gt;d[i]: i的约数个数&lt;/li&gt;
&lt;li&gt;sumd[i]
      
    
    </summary>
    
      <category term="Studies" scheme="http://stardustdl.github.io/Blog/categories/Studies/"/>
    
    
      <category term="CS" scheme="http://stardustdl.github.io/Blog/tags/CS/"/>
    
  </entry>
  
  <entry>
    <title>码题助手</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/22/%E7%A0%81%E9%A2%98%E5%8A%A9%E6%89%8B/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/22/码题助手/</id>
    <published>2017-12-22T15:07:41.000Z</published>
    <updated>2017-12-23T12:05:07.602Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>感谢来读，语文不好，表达有问题的还请指出。以下这段只是我的吐槽，可以跳过。</p></blockquote><p>这个“助手”是这样来的：写题的时候，用了vscode后根本无法忍受devcpp的“丑陋”，然而vscode对C++的编译支持的并不好，一时间陷入两难。最终决定写个程序简化编译等做题中常用的功能，现在配合vscode十分舒服。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>名称：acm（因为是码题用的）</li><li>功能：<ul><li>配置外部编译器编译</li><li>使用代码模板</li><li>自动输入输出</li><li>自动测量程序运行时间与使用内存（准确度一般）</li><li>自动使用用户提供的数据判题（具体见后文）。</li></ul></li><li>版本：v1.0</li><li>作者：Stardust D.L.（Liang）</li><li>支持系统：原生Windows 10，Mac OS 10+</li></ul><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><ul><li><a href="http://osyor26xu.bkt.clouddn.com/win10-64.rar" target="_blank" rel="noopener">Windows 10</a></li><li><a href="http://osyor26xu.bkt.clouddn.com/acm/osx10-64.zip" target="_blank" rel="noopener">Mac OS</a></li></ul><h1 id="个人使用体会"><a href="#个人使用体会" class="headerlink" title="个人使用体会"></a>个人使用体会</h1><p>我比较习惯编辑器+命令行的写程序方式，然后每次编译都要写 <code>g++ a.cpp -o a</code> 这么长，很烦，然后就写了这么个简化命令的程序。不过对于习惯GUI的人，可能体验上还是不如GUI。</p><p>觉得最好用的是 <code>check</code> 功能，每次写题，先把输入和标准输出打进去，然后改完代码直接check，就能知道这组数据过没过，比以前每次重新输入，目测比对方便多了（已经习惯这种方式了）。</p><p>不过怎么着也是个自己用的工具，写的还很简单，不过平常写题用着还是比较方便的。发出来要是能帮到人就很开心了。</p><p>至于这个怎么用。。。看看下面的就好了，比C++简单多了（233<br>另外一些具体内容我没写，（懒</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="第0步"><a href="#第0步" class="headerlink" title="第0步"></a>第0步</h2><ul><li>解压就好了</li><li>如果需要请将解压目录加入系统环境变量(*)</li><li>请在使用前先将命令行当前目录指定到码题的工作目录（<code>cd myfolder</code>）</li></ul><h2 id="第1步：准备"><a href="#第1步：准备" class="headerlink" title="第1步：准备"></a>第1步：准备</h2><ol><li>命令行调用 acm（如果您已完成(*)）</li><li>如果当前目录不存在acm环境，会显示白色字样，已存在的话会显示绿色 <code>Loaded</code> 字样。接下来等待输入命令</li><li>等待输入的行头可能有两种：<ul><li><code>&gt;</code> </li><li><code>c.cpp &gt;</code> ：当前代码文件为c.cpp</li></ul></li></ol><h2 id="第2步：命令介绍"><a href="#第2步：命令介绍" class="headerlink" title="第2步：命令介绍"></a>第2步：命令介绍</h2><p>调用完 <code>init</code> 命令就先去配置吧（第3步），配置完再开始用别的命令。</p><ul><li><code>init</code> 初始化acm环境</li><li><code>clear</code> 清除acm环境</li><li><code>exit</code> 退出</li><li><code>cls</code> 清空命令行</li><li><code>reload</code> 重新载入（设置等）</li><li><code>build</code> 编译当前文件</li><li><code>run</code> 运行已编译的文件</li><li><code>br</code> 等价于build and run</li><li><code>new &lt;filename&gt; [-c]</code> 新建文件，<code>filename</code> 请带上扩展名，这样系统会自动匹配您提供的代码模板，<code>-c</code> 可选，指示系统自动将此文件设置为当前文件。</li><li><code>kill</code> 干掉运行中的程序（比如死循环了TAT）</li><li><code>check</code> 对当前代码，自动编译执行，自动输入输出，自动比对答案。（个人最满意的功能），会显示评测结果和运行时间内存等，注意这里判题是<strong>简单比对</strong>，一般是忽视行尾空格的（其实就是系统命令<code>fc</code>）<h3 id="关于check功能"><a href="#关于check功能" class="headerlink" title="关于check功能"></a>关于check功能</h3>请将输入写到<code>\.acm\input.in</code>，标准输出写到<code>\.acm\std.ans</code>，然后调用<code>check</code>。</li></ul><h2 id="第3步：系统配置"><a href="#第3步：系统配置" class="headerlink" title="第3步：系统配置"></a>第3步：系统配置</h2><p>这里很关键，不过也简单。</p><p><strong>建议安装MinGW(Devcpp 自带，在安装目录的MinGW64目录下），这样下面的编译器设置就可以指定为 类似这样的</strong><br><code>D:\MinGW\bin\g++.exe</code></p><p>acm环境初始化后，系统会在当前目录创建隐藏文件夹<code>.acm</code>，介绍如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.acm\</span><br><span class="line">templates\ 代码模板们（文件名必须是 base.扩展名）</span><br><span class="line">base.c 默认C代码模板</span><br><span class="line">base.cpp 默认C++代码模板</span><br><span class="line">input.in 输入文件</span><br><span class="line">output.out 输出文件（有输出时会产生）</span><br><span class="line">std.ans 正确输出</span><br><span class="line">checker.json 评测标准</span><br><span class="line">builder.json 编译配置</span><br><span class="line">config.json 系统设置</span><br></pre></td></tr></table></figure><p>相关配置文件设置：（能看懂的我就不写了，以下给出的都是建议配置（当然系统环境不同可能会有调整），另外文件为json格式，默认无缩进，可以使用代码格式化工具加上缩进（比如vscode使用快捷键 <code>alt+shift+F</code> ）</p><p><strong>重点</strong><br>一般只有config.json中的 <code>UseFileInput,UseFileOutput</code> 改为<code>true</code>，builder.json的编译器指定（如果没有把 g++ 加到环境变量中的话）两处需要修改。</p><h3 id="checker-json"><a href="#checker-json" class="headerlink" title="checker.json"></a>checker.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"MemoryLimitMB"</span>: <span class="number">256</span>,</span><br><span class="line">    <span class="attr">"TimeLimitMS"</span>: <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="builder-json"><a href="#builder-json" class="headerlink" title="builder.json"></a>builder.json</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "WaitTime": 10000, //编译最大时限</span><br><span class="line">    "builders": [</span><br><span class="line">        &#123;</span><br><span class="line">            "Key": 2,//2代表C++编译器</span><br><span class="line">            "Value": &#123;</span><br><span class="line">"Arguments": "#input -o #output",</span><br><span class="line">//编译参数，请用#input 代替输入，#output 代替输出，这与编译器所使用的命令格式有关</span><br><span class="line"></span><br><span class="line">                "Command": "g++"//编译器程序命令（或程序路径）</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            "Key": 1,//1代表C编译器</span><br><span class="line">            "Value": &#123;</span><br><span class="line">                "Arguments": "#input -o #output",</span><br><span class="line">                "Command": "gcc"</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="config-json"><a href="#config-json" class="headerlink" title="config.json"></a>config.json</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "Templates": &#123;//代码模板设置，这里不说明了（我懒了）</span><br><span class="line">        "CodeTemplateBase": [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Key"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"\/templates\/base.c"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"Key"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"Value"</span>: <span class="string">"\/templates\/base.cpp"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    "UseFileInput": true,//是否使用文件（input.in）自动输入</span><br><span class="line">    "UseFileOutput": true//是否自动输出到文件（output.out）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改配置后一定要用<code>reload</code>命令重新加载，不然配置只有下次启动acm时才生效。</p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>个人感觉最佳搭配编辑器为 Visual Code，使用其内置的终端可以使得编辑与执行始终在一个界面。</p><p>可能会有Bug，使用时请留意。<br>谢谢使用。</p><p>本文档可能会有修改。</p><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><ul><li>可能以后会加上HDU，POJ自动提交功能（其实已经实现了，然而没空写细节）</li><li>理论上是能跨平台的（比如支持Linux，Mac OS），然而不同系统API不同，技术所限，暂时不支持。要是有同学会 .Net Core 还请教教我。</li><li>还有什么建议欢迎发到我邮箱。</li></ul><h1 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h1><p><a href="https://github.com/gsscoder/commandline/tree/master" target="_blank" rel="noopener">CommandLine</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;感谢来读，语文不好，表达有问题的还请指出。以下这段只是我的吐槽，可以跳过。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个“助手”是这样来的：写题的时候，用了vscode后根本无法忍受devcpp的“丑陋”，然而vscode对C++的编译支持的并不
      
    
    </summary>
    
      <category term="Designs" scheme="http://stardustdl.github.io/Blog/categories/Designs/"/>
    
    
      <category term="Apps" scheme="http://stardustdl.github.io/Blog/tags/Apps/"/>
    
  </entry>
  
  <entry>
    <title>iExpr 编程示例与常用运行时函数</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/22/iExpr-Examples/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/22/iExpr-Examples/</id>
    <published>2017-12-22T06:08:44.000Z</published>
    <updated>2017-12-23T11:58:47.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qpow=(a,n)=&gt;func(</span><br><span class="line">    return=1,</span><br><span class="line">    while(n&gt;=1,</span><br><span class="line">    [</span><br><span class="line">        if(n%2==1,return=return*a),</span><br><span class="line">        a=a*a,</span><br><span class="line">        n=floor(n/2)</span><br><span class="line">    ])</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="函数极小值"><a href="#函数极小值" class="headerlink" title="函数极小值"></a>函数极小值</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eps=0.000001,</span><br><span class="line">fmin=&gt;(ex,x0)=&gt;func(</span><br><span class="line">    p:=diffi(ex,x0),</span><br><span class="line">    t:=0.3*p,</span><br><span class="line">    while(abs(t)&gt;=eps,[</span><br><span class="line">        x0=x0-t,</span><br><span class="line">        p=diffi(ex,x0),</span><br><span class="line">        t=0.3*p]),</span><br><span class="line">    return=x0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dmul=(a,b)=&gt;func(</span><br><span class="line">    return=[],</span><br><span class="line">    foreach(a,x,</span><br><span class="line">        foreach(b,y,</span><br><span class="line">            return=cup(return,[tuple(x,y)]))))</span><br></pre></td></tr></table></figure><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fac=(n)=&gt;func(</span><br><span class="line">    if(n&gt;0,</span><br><span class="line">        return=n*fac(n-1),</span><br><span class="line">        return=1)),</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sort=(l)=&gt;func(</span><br><span class="line">    n:=l.len(),</span><br><span class="line">    for(i=0,i&lt;n,i=i+1,</span><br><span class="line">        for(j=i+1,j&lt;n,j=j+1,</span><br><span class="line">            if(val(l,i)&gt;val(l,j),</span><br><span class="line">                [t:=val(l,i),</span><br><span class="line">                val(l,i,val(l,j)),</span><br><span class="line">                val(l,j,t)]</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    ),</span><br><span class="line">    return=l</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="以下函数已有预定义函数，此为近似实现"><a href="#以下函数已有预定义函数，此为近似实现" class="headerlink" title="以下函数已有预定义函数，此为近似实现"></a>以下函数已有预定义函数，此为近似实现</h2><h1 id="生成-1-2-…n"><a href="#生成-1-2-…n" class="headerlink" title="生成 [1,2,…n]"></a>生成 [1,2,…n]</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">range=(a,b)=&gt;func(</span><br><span class="line">    return=[],</span><br><span class="line">    for(i:=a,i&lt;=b,i=i+1,</span><br><span class="line">        return=cup(return,[i])))</span><br></pre></td></tr></table></figure><h1 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select=(l,f)=&gt;func(</span><br><span class="line">    n:=len(l),</span><br><span class="line">    return=array(n),</span><br><span class="line">    for(i:=0,i&lt;n,i=i+1,</span><br><span class="line">        val(return,i,f(val(l,i)))</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="挑选函数"><a href="#挑选函数" class="headerlink" title="挑选函数"></a>挑选函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">where=(l,f)=&gt;func(</span><br><span class="line">    return=[],</span><br><span class="line">    foreach(l,x,</span><br><span class="line">        if(f(x),</span><br><span class="line">            return=return.cup([x])</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速幂&quot;&gt;&lt;a href=&quot;#快速幂&quot; class=&quot;headerlink&quot; title=&quot;快速幂&quot;&gt;&lt;/a&gt;快速幂&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
      <category term="Designs" scheme="http://stardustdl.github.io/Blog/categories/Designs/"/>
    
    
  </entry>
  
  <entry>
    <title>iExpr 更新介绍</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/22/iExpr-%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/22/iExpr-更新介绍/</id>
    <published>2017-12-22T06:06:25.000Z</published>
    <updated>2017-12-23T11:41:25.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本-1-3"><a href="#版本-1-3" class="headerlink" title="版本 1.3"></a>版本 1.3</h1><ul><li>引入了 Lambda 表达式<ul><li>示例：<code>(x,y,z)=&gt;(x+y+z)</code></li><li>可以使用 Lambda 表达式 表示函数，如果配合 <code>func</code> 则能定义极为复杂的函数</li></ul></li><li>我们使用 Lambda 表达式 重写了 求导和积分 的表达方式，现在的表达更加自然<ul><li><code>diff((x)=&gt;x^2)</code></li></ul></li><li>通过 Lambda 表达式 ，现在的函数定义和调用也有所调整。详情请见说明文档</li><li>引入了 <code>foreach</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;版本-1-3&quot;&gt;&lt;a href=&quot;#版本-1-3&quot; class=&quot;headerlink&quot; title=&quot;版本 1.3&quot;&gt;&lt;/a&gt;版本 1.3&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;引入了 Lambda 表达式&lt;ul&gt;
&lt;li&gt;示例：&lt;code&gt;(x,y,z)=&amp;gt;(x+y
      
    
    </summary>
    
      <category term="Designs" scheme="http://stardustdl.github.io/Blog/categories/Designs/"/>
    
    
  </entry>
  
  <entry>
    <title>表达式计算器-iExpr</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/22/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8-iExpr/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/22/表达式计算器-iExpr/</id>
    <published>2017-12-22T05:53:24.000Z</published>
    <updated>2017-12-23T14:20:15.355Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://stardustdl.github.io/Blog/2017/12/22/iExpr-%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D/">版本更新内容</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>个人设计的一个表达式计算器，支持以下功能</p><ul><li>带关系运算和逻辑运算的数学表达式解析与计算</li><li>支持常见数学函数</li><li>表达式带变量运算，变量赋值运算</li><li>支持简单求导（实现十分简单，所以支持的函数很少，但很多函数可以使用伪求导），定积分求值等运算</li><li>简单逻辑表达式的解析与计算</li><li>绘制函数图象</li><li>打印真值表</li><li>使用编程方式进行一些复杂运算</li></ul><p>系统要求：Windows 10 秋季创意者更新（16299）</p><blockquote><p><strong>制作目的为对已学习知识的实践</strong>，以使用的方便灵活为主要目标。<br>由于制作时间短，本程序仍存在不少Bug，详情请见备注。<br>目前版本仍为<strong>测试版本</strong>，稳定性不足，还请注意程序得到的结果是否正确。<br>如果您想反馈Bug，我是非常欢迎的，邮箱为 stardustdl@163.com<br>但由于是个人业余开发者，更新周期不定，Bug修复时间不定。</p></blockquote><h1 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h1><h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p><img src="http://img.blog.csdn.net/20171209235059426?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRDA0MjQxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="数学表达式"></p><h2 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h2><p><img src="http://img.blog.csdn.net/20171209235213832?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRDA0MjQxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="逻辑表达式"></p><h2 id="函数绘图"><a href="#函数绘图" class="headerlink" title="函数绘图"></a>函数绘图</h2><p><img src="http://img.blog.csdn.net/20171209235226240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRDA0MjQxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="函数绘图"></p><h2 id="编程页面"><a href="#编程页面" class="headerlink" title="编程页面"></a>编程页面</h2><p><img src="http://img.blog.csdn.net/20171209235238723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRDA0MjQxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="编程页面"></p><h1 id="下载在这里"><a href="#下载在这里" class="headerlink" title="下载在这里"></a><a href="https://www.microsoft.com/store/apps/9P1CLV99C3VT" target="_blank" rel="noopener">下载在这里</a></h1><p><strong>以下为使用说明。</strong></p><h1 id="iExpr-使用说明"><a href="#iExpr-使用说明" class="headerlink" title="iExpr 使用说明"></a>iExpr 使用说明</h1><ul><li>本说明版本：2017.12.9</li><li>适用软件版本：<strong>iExpr 1.3</strong> </li><li>下载在<a href="https://www.microsoft.com/store/apps/9P1CLV99C3VT" target="_blank" rel="noopener">这里</a></li></ul><h1 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h1><p>iExpr 分为四个页面，分别为数学表达式，逻辑表达式，数学表达式图像，编程页面。</p><p>表达式页面头部有表达式编辑框（回车解析，Esc取消运算），其下有两栏，</p><ul><li>第一栏会显示表达式计算结果（如果解析失败也会将提示信息显示在这里）。</li><li>第二栏会显示表达式解析结果，可以在这里检查系统解析的表达式是否符合预期。</li></ul><p>表达式页面主体部分会提供相关扩展功能。</p><p>您切换页面时原页面中的信息会被清空，所以请保留好您需要的信息（如输入表达式）。</p><h1 id="表达式-基本语法"><a href="#表达式-基本语法" class="headerlink" title="表达式 基本语法"></a>表达式 基本语法</h1><ul><li><code>()</code> </li></ul><p>小括号用于区分优先级与包围函数参数</p><ul><li><code>@&quot;abc&quot;</code> </li></ul><p>表示其中的内容(abc)为一个整体，常用来表示预定义常量（不同表达式系统中可能有不同的预定义常量表示），有时也用于被运算者独立解析的函数参数或指定变量名。</p><ul><li><code>F(arg1,arg2,...)</code> </li></ul><p>函数格式（<code>F</code> 在这里包含自定义的函数以及 Lambda 表达式，关于自定义的函数 具体请见编程部分）。注：函数的运算优先级最高</p><ul><li><code>a b c d</code></li></ul><p>表达式支持变量表示，首字符不为数字或运算符（函数）关键字的一般都会解析为变量，但仍强烈建议使用<strong>纯字母</strong>或<strong>字母+数字</strong>的方式表示变量。</p><ul><li><code>(v1,v2,...)=&gt;(expr)</code></li></ul><p>Lambda 表达式，可以理解为自己定义的一个自变量为 $v1,v2,v3,\dots$ 的函数</p><ul><li><code>x.func(args)</code></li></ul><p>调用函数，对于部分支持前置参数的函数，可以这样调用，其等价于 <code>func(x,args)</code></p><h2 id="集合类型表示"><a href="#集合类型表示" class="headerlink" title="集合类型表示"></a>集合类型表示</h2><ul><li><code>[1,2,a^2,5]</code></li></ul><p>列表，用 <code>[]</code> 包围表示这是一个列表，其中元素以 <code>,</code> 分隔</p><ul><li><code>{1,2,a^2,5}</code></li></ul><p>无序不重集合，用 <code>{}</code> 包围表示这是一个集合，其中元素以 <code>,</code> 分隔</p><ul><li><code>(1,2,a^2,5)</code></li></ul><p>定长元组，用 <code>()</code> 包围表示这是一个元组，其中元素以 <code>,</code> 分隔</p><h1 id="基础表达式系统"><a href="#基础表达式系统" class="headerlink" title="基础表达式系统"></a>基础表达式系统</h1><p>为各表达式系统的基础</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li><code>=&gt;</code> Lambda 表达式定义</li><li><code>.</code> 层级调用</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><code>list(l1,l2,...)</code></li></ul><p>生成列表，参数中的单层集合会被展开。</p><ul><li><code>tuple(l1,l2,...)</code></li></ul><p>生成元组，参数中的单层集合会被展开。</p><ul><li><code>set(l1,l2,...)</code></li></ul><p>生成集合，参数中的单层集合会被展开。</p><ul><li><code>len(l1,l2,...)</code></li></ul><p>统计元素数目，参数中的单层集合会被展开。</p><ul><li><code>val(l,index)</code></li></ul><p>获取列表 <code>l</code> 中的第 <code>index</code> 项（从0开始计数）</p><ul><li><code>val(l,index，newval)</code></li></ul><p>将列表 <code>l</code> 中的第 <code>index</code> 项（从0开始计数）设为 <code>newval</code></p><h1 id="数学表达式系统"><a href="#数学表达式系统" class="headerlink" title="数学表达式系统"></a>数学表达式系统</h1><p>以下变量除特殊标明外都默认为实数类型。</p><h2 id="基本部分"><a href="#基本部分" class="headerlink" title="基本部分"></a>基本部分</h2><h3 id="运算符（优先级从低到高）"><a href="#运算符（优先级从低到高）" class="headerlink" title="运算符（优先级从低到高）"></a>运算符（优先级从低到高）</h3><ul><li><code>+</code> 加</li><li><code>-</code> 减，包含取负，<strong>注意这里优先级较低，使用x^-1时请写成x^(-1)</strong></li><li><code>*</code> 乘</li><li><code>/</code> 除</li><li><code>%</code> 取模</li><li><code>^</code> 指数<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3></li><li><code>sin(x)</code> 正弦函数</li><li><code>cos(x)</code> 余弦函数</li><li><code>tan(x)</code> 正切函数</li><li><code>arcsin(x)</code> 反正弦函数</li><li><code>arccos(x)</code> 反余弦函数</li><li><code>arctan(x)</code> 反正切函数</li><li><code>log(base,val)</code> 对数</li><li><code>ln(val)</code> 自然对数</li><li><code>abs(x)</code> 绝对值</li><li><code>round(x)</code> 舍入到最精确的整数</li><li><code>ceil(x)</code> 大于等于x的最小整数</li><li><code>floor(x)</code> 小于等于x的最小整数</li><li><code>exp(x)</code> e的幂次</li><li><code>sign(x)</code> x的符号</li></ul><h3 id="常量值"><a href="#常量值" class="headerlink" title="常量值"></a>常量值</h3><ul><li><code>e</code> 自然对数的底数</li><li><code>pi</code> 圆周率</li></ul><h2 id="扩展部分"><a href="#扩展部分" class="headerlink" title="扩展部分"></a>扩展部分</h2><h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><p>这里主要扩展了关系运算和简单逻辑运算，它们的结果为0或1。</p><ul><li><code>|</code> 或</li><li><code>&amp;</code> 且</li><li><code>==</code> 相等</li><li><code>!=</code> 不等</li><li><code>&gt;</code> 大于</li><li><code>&lt;</code> 小于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li></ul><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><ul><li><code>eval(expr,v1,v2,...)</code> </li></ul><p>将expr中的变量按给出的值依次赋值（字典序），然后求值</p><ul><li><code>sum(expr,l,r)</code> </li></ul><script type="math/tex; mode=display">\sum_l^r{expr}</script><p>变量自l到r（会自动转换为整数）遍历，带入expr求值（expr中应只含有一个变量），然后累加。 </p><ul><li><code>prod(expr,l,r)</code> </li></ul><script type="math/tex; mode=display">\prod_l^r{expr}</script><p>变量自l到r遍历（会自动转换为整数），带入expr求值（expr中应只含有一个变量），然后累乘。 </p><h4 id="微积分部分"><a href="#微积分部分" class="headerlink" title="微积分部分"></a>微积分部分</h4><ul><li><code>diff((vid)=&gt;(expr))</code></li></ul><script type="math/tex; mode=display">\frac{\mathrm{d}\,expr}{\mathrm{d}\,vid}</script><p>初等函数求导</p><ul><li><code>diffi((vid)=&gt;(expr),x0)</code></li></ul><script type="math/tex; mode=display">\frac{f(x_0+step)-f(x_0)}{step}</script><p>使用差分计算 $x_0$ 处切线斜率。默认 step=0.001</p><ul><li><code>integ((x)=&gt;(expr),l,r)</code></li></ul><script type="math/tex; mode=display">\int_l^r{expr}\,\mathrm{d}\,x</script><p><code>expr</code>（单变量函数，变量名会自动选择）在 $[l,r]$ 上的定积分模拟：精度默认值为 $10^{-6}$</p><h4 id="数论部分"><a href="#数论部分" class="headerlink" title="数论部分"></a>数论部分</h4><ul><li><code>gcd(int x,int y)</code></li></ul><p>最大公因数</p><ul><li><code>lcm(int x,int y)</code></li></ul><p>最小公倍数</p><h4 id="统计部分"><a href="#统计部分" class="headerlink" title="统计部分"></a>统计部分</h4><ul><li><code>min(v1,v2,...)</code></li></ul><p>最小值，其中参数可以为集合类型，嵌套集合类型会被展开</p><ul><li><code>max(v1,v2,...)</code></li></ul><p>最大值，其中参数可以为集合类型，嵌套集合类型会被展开</p><ul><li><code>total(v1,v2,...)</code></li></ul><p>总和，其中参数可以为集合类型，嵌套集合类型会被展开</p><ul><li><code>mean(v1,v2,...)</code></li></ul><p>平均值，其中参数可以为集合类型，嵌套集合类型会被展开</p><h4 id="集合部分"><a href="#集合部分" class="headerlink" title="集合部分"></a>集合部分</h4><ul><li><code>cup(v1,v2,...)</code></li></ul><script type="math/tex; mode=display">\bigcup v_i</script><p>并集，其中参数必须为集合类型</p><ul><li><code>cap(v1,v2,...)</code></li></ul><script type="math/tex; mode=display">\bigcap v_i</script><p>交集，其中参数必须为集合类型</p><ul><li><code>dif(v1,v2,...)</code></li></ul><script type="math/tex; mode=display">v_1 \setminus v2 \setminus v3 \setminus \dots</script><p>差集（v1-v2-v3-…），其中参数必须为集合类型</p><h2 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h2><p>在代值页面点击刷新会加载当前表达式所有有意义变量（部分变量可能会在计算中被化简掉），设置变量值后点击计算会在计算结果区显示结果。</p><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>对于单变量表达式，在图像页面可以绘制其图像。</p><p>可以使用右侧按钮或鼠标滚轮放大缩小。拖动界面可移动绘图区域。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>1+(2*3-5^2)/4</li><li>sum((x%2==0)*x,1,10)</li><li>diffi(x=&gt;abs(x),2)</li></ul><p>绘图例子：</p><ul><li>x^3</li><li>diffi(x=&gt;abs(x),x)</li><li>integ(x=&gt;e^(-x^2),0,x)</li></ul><h1 id="逻辑表达式-1"><a href="#逻辑表达式-1" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h1><h2 id="运算符（优先级从低到高）-1"><a href="#运算符（优先级从低到高）-1" class="headerlink" title="运算符（优先级从低到高）"></a>运算符（优先级从低到高）</h2><ul><li><code>-&gt;</code> 推出</li><li><code>&lt;-&gt;</code> 等价</li><li><code>|</code> 或</li><li><code>^</code> 异或</li><li><code>&amp;</code> 且</li><li><code>!</code> 非</li></ul><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul><li><code>true,True</code> 真</li><li><code>false,False</code> 假</li></ul><h2 id="求值-1"><a href="#求值-1" class="headerlink" title="求值"></a>求值</h2><p>在代值页面点击刷新会加载当前表达式所有有意义变量（部分变量可能会在计算中被化简掉），设置变量值后点击计算会在计算结果区显示结果。</p><h1 id="数学表达式图像部分"><a href="#数学表达式图像部分" class="headerlink" title="数学表达式图像部分"></a>数学表达式图像部分</h1><p>界面类似数学表达式部分的图像页面，但这里支持多个函数图像绘制。</p><p>解析器将会把每行解析为一个单变量函数，可以接受以下表达式</p><pre><code>+ 普通单变量表达式 `x^2`+ 单变量 Lambda 表达式 `x=&gt;x^2` `x=&gt;func(return=x^2)`</code></pre><p>这里的表达式解析基于下面将要提到的编程表达式，所以您可以使用丰富的编程函数构建复杂的函数。</p><p>左栏下方会显示所画的函数与颜色的对于关系，拖动右侧图像区域可以移动，支持滚轮缩放，但这会导致重新绘图，对于复杂函数可能需要等待绘图完成。</p><h1 id="编程部分"><a href="#编程部分" class="headerlink" title="编程部分"></a>编程部分</h1><blockquote><p>此部分还不是很成熟，使用时请适当注意</p></blockquote><p>支持<strong>数学表达式</strong>的代码式运算。点击上方按钮（或F5）即可运行，Esc键取消运行。如果有错误会在下方显示错误信息。</p><p>请使用如下语法（其中expr1,expr2,…是语句，注意用逗号分隔）：</p><pre><code>&gt; 此版本不再需要输入 `exec` 函数</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expr1,</span><br><span class="line">expr2,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="语句语法"><a href="#语句语法" class="headerlink" title="语句语法"></a>语句语法</h2><ul><li>赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=1,</span><br><span class="line">v=[1,2,3]</span><br></pre></td></tr></table></figure><p>将指定名称变量赋值成右侧表达式的值，这里要求右侧表达式的值必须是能计算出确定值的表达式。</p><ul><li>独立赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x:=1,</span><br><span class="line">v:=[1,2,3]</span><br></pre></td></tr></table></figure></li></ul><p>功能和赋值语句相同，但他会在当前环境新建变量，从而隐藏掉父级的同名变量。</p><ul><li>弱声明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def(id,expr)</span><br></pre></td></tr></table></figure></li></ul><p>将指定名称的变量赋成右侧的表达式，这里<strong>不</strong>要求右侧表达式的值必须是常量（即可以是类似<code>x^2</code>这样的含变量表达式。</p><ul><li>函数块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(expr1,expr2,...)</span><br></pre></td></tr></table></figure></li></ul><p>函数块会自动新定义一个名为 <code>return</code> 的变量（初值为 <code>Null</code> ），函数块的结果为依次执行 <code>expr</code> 后 <code>return</code> 的值。</p><ul><li>过程块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action(expr1,expr2,...)</span><br></pre></td></tr></table></figure></li></ul><p>过程块会依次执行 <code>expr</code> ，然后返回空值。</p><ul><li>运行时函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=(v1,v2,...)=&gt;(expr)</span><br></pre></td></tr></table></figure></li></ul><p>构建一个运行时函数，其参数名为 <code>v1,v2,...</code> 。内部代码为 <code>expr</code>，结果为计算 <code>expr</code> 后的结果（这里可以用 <code>func</code> 构建 <code>expr</code> ）(这里运行时函数的本质就是一个 Lambda 表达式）</p><blockquote><p>与赋值类似，<code>def</code> 也有相对应的 <code>redef</code> 独立声明</p></blockquote><ul><li>调用运行时函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id(args)</span><br></pre></td></tr></table></figure><p>和调用预定义函数的用法相同。</p><blockquote><p>以下用法已弃用<br>call(fid,arg1,arg2,…)</p></blockquote><h3 id="程序控制函数"><a href="#程序控制函数" class="headerlink" title="程序控制函数"></a>程序控制函数</h3><ul><li><p>循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(begin,cond,step,expr)</span><br><span class="line">while(cond,expr)</span><br><span class="line">do(expr,cond)</span><br><span class="line">foreach(list,varName,expr)</span><br></pre></td></tr></table></figure></li><li><p>条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(cond,then-expr,else-expr)</span><br></pre></td></tr></table></figure></li></ul><h3 id="更多函数"><a href="#更多函数" class="headerlink" title="更多函数"></a>更多函数</h3><ul><li><code>array(n,defaultVal)</code></li></ul><p>生成 $n$ 个元素的元组，初始值为 <code>defaultVal</code> （可省略，默认为空值）</p><ul><li><code>range(l,r)</code></li></ul><p>生成 $[l,r]$ 的整数序列</p><ul><li><code>random(l,r)</code></li></ul><p>生成 $[l,r)$ 范围内的随机整数</p><ul><li><code>sort(list,cmpFunc)</code></li></ul><p>升序排序，<code>cmp</code> 转换函数（Lambda 表达式）</p><ul><li><code>select(list,transFunc)</code></li><li><code>where(list,condFunc)</code></li><li><code>zip(list,zipFunc)</code></li></ul><p>这几个函数和函数式编程中常用的三个同名函数意义相同，具体使用请参见 <strong>更多算法和例子</strong></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>更多算法和例子请见 <a href="https://stardustdl.github.io/Blog/2017/12/22/iExpr-Examples/">这里</a></p><ul><li>基本计算<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exec(</span><br><span class="line">list=[1,2,3],</span><br><span class="line">def(f,x^2),</span><br><span class="line">s=total(list),</span><br><span class="line">s,</span><br><span class="line">diff(f,@&quot;x&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>其结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">(2*(x^1))*1</span><br></pre></td></tr></table></figure></p><ul><li>简单算法</li></ul><p>快速幂计算模意义下的幂（模数较大且幂次较高时会有较大精度误差）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exec(</span><br><span class="line">mod=13331,</span><br><span class="line">def(qpow,(a,n),</span><br><span class="line">    func(</span><br><span class="line">        return=1,</span><br><span class="line">        while(n&gt;=1,</span><br><span class="line">        [</span><br><span class="line">            if(n%2==1,return=return*a%mod),</span><br><span class="line">            a=a*a%mod,</span><br><span class="line">            n=floor(n/2)</span><br><span class="line">        ])</span><br><span class="line">    )</span><br><span class="line">),</span><br><span class="line">call(qpow,2,15)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>仍为测试版本，正在收集各式各样的Bug，已知Bug如下</p><blockquote><ul><li>绘图部分不稳定，尤其是复杂函数绘制和极大极小缩放场景</li><li>变量识别有漏洞</li></ul></blockquote><p>部分Bug将在下一版本中修复。</p><p>编程部分将有较大改动，将支持自定义函数：</p><p><img src="http://img.blog.csdn.net/20171214193455398?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRDA0MjQxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="预览图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://stardustdl.github.io/Blog/2017/12/22/iExpr-%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D/&quot;&gt;版本更新内容&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介
      
    
    </summary>
    
      <category term="Designs" scheme="http://stardustdl.github.io/Blog/categories/Designs/"/>
    
    
      <category term="Apps" scheme="http://stardustdl.github.io/Blog/tags/Apps/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://stardustdl.github.io/Blog/2017/12/22/hello-world/"/>
    <id>http://stardustdl.github.io/Blog/2017/12/22/hello-world/</id>
    <published>2017-12-22T03:07:18.605Z</published>
    <updated>2017-12-22T09:44:25.164Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
