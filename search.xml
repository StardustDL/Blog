<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法正确性证明]]></title>
    <url>%2FBlog%2F2018%2F03%2F12%2F%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[例子 抽象例子 12345678910Procedure ALG #P Init #I while C #I and C S #I and not C Follow #Q 目标：P{ALG}QP\{ALG\}QP{ALG}Q 途径： P{Init}IP\{Init\}IP{Init}I (I∧C){S}I(I\wedge C)\{S\}I(I∧C){S}I (I∧¬C){Follow}Q(I\wedge \neg C)\{Follow\}Q(I∧¬C){Follow}Q 注意 循环不变量不唯一但强度不同 实际例子 12345678910111213141516171819equal(S1,S2) #P X=S1 Y=S2 E=true #I while X!=null &amp;&amp; Y!=null &amp;&amp; E if eq(head(X),head(Y)) X=tail(X) Y=tail(Y) else E=false #A if !(X==null &amp;&amp; Y==null) E=false #B else #C return E 不变量 P:(S1isstring)∧(S2isstring)P: (S_1 is string)\wedge(S_2 is string)P:(S1​isstring)∧(S2​isstring) I:S1=S2⇔E∧X=YI: S_1=S_2 \Leftrightarrow E\wedge X=YI:S1​=S2​⇔E∧X=Y A:I∧(X==null∨Y==null∨¬E)A: I\wedge (X==null \vee Y==null \vee \neg E)A:I∧(X==null∨Y==null∨¬E) B:A∧¬(X==null∧Y==null)B: A\wedge \neg (X==null \wedge Y==null)B:A∧¬(X==null∧Y==null) C:A∧X==null∧Y==nullC: A\wedge X==null \wedge Y==nullC:A∧X==null∧Y==null Q:S1=S2⇔EQ: S_1=S_2 \Leftrightarrow EQ:S1​=S2​⇔E 证明内容 P⇒I1P \Rightarrow I_1P⇒I1​ I1⇒I1I_1 \Rightarrow I_1I1​⇒I1​ I1⇒I2I_1 \Rightarrow I_2I1​⇒I2​ I2⇒I3I_2 \Rightarrow I_3I2​⇒I3​ I2⇒I4I_2 \Rightarrow I_4I2​⇒I4​ (I3⇒Q)∧(I4⇒Q)(I_3 \Rightarrow Q) \wedge (I_4 \Rightarrow Q)(I3​⇒Q)∧(I4​⇒Q)]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DailyCheckin 日程管理]]></title>
    <url>%2FBlog%2F2018%2F02%2F05%2FDailyCheckin-%E6%97%A5%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[介绍 一个简约的日程管理软件。 您可以给日程分类，打上标记，选择推迟或设置重要性。 链接 反馈收集 请于下方评论区留言，谢谢。]]></content>
      <categories>
        <category>Designs</category>
      </categories>
      <tags>
        <tag>Apps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackerRank HourRank 25]]></title>
    <url>%2FBlog%2F2018%2F01%2F03%2FHackerRank-HourRank-25%2F</url>
    <content type="text"><![CDATA[Constructing a Number 计算用给出数的所有数位能否组成一个 333 的倍数 按位累加判断是否是 333 的倍数。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int t,n,a;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; int sum=0; while(n--)&#123; cin&gt;&gt;a; while(a)&#123; sum=(sum+a%10)%3; a/=10; &#125; &#125; puts(sum==0?"Yes":"No"); &#125; return 0;&#125; Maximum Palindromes 计算使用一个给定字符串的子串中所有字母构成的最长回文串有多少种。每次询问一个子串，1≤∣S∣,q≤1051 \leq |S|,q \leq 10^51≤∣S∣,q≤105，模 109+710^9+7109+7 的值。 预处理每个字母次数的前缀和，预处理阶乘及其逆，直接用多重排列算回文串前一半有多少种。 P(n;r1,r2,…,rk)=n!r1!r2!…rk!P(n;r_1,r_2,\dots,r_k)=\frac{n!}{r_1!r_2!\dots r_k!} P(n;r1​,r2​,…,rk​)=r1​!r2​!…rk​!n!​ 注意回文串中间一位可以是无配对的字母（如 aba），再统计出现奇数次的字母种数乘起来即可。 第一次交，在最后乘法的时候忘记取模了！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN=1e5;typedef long long LL;const LL MOD=1e9+7;int q;char s[MAXN+10];int cnt[MAXN+10][26];int _c[26];LL fac[MAXN+10],inv[MAXN+10];LL qpow(LL x,LL n)&#123; LL ans=1; while(n)&#123; if(n&amp;1)ans=ans*x%MOD; x=x*x%MOD; n&gt;&gt;=1; &#125; return ans;&#125;LL solve(int l,int r)&#123; int s=0,rs=0; for(int j=0;j&lt;26;j++)&#123; _c[j]=cnt[r][j]-cnt[l-1][j]; if(_c[j]&amp;1)&#123; _c[j]--; rs++; &#125; s+=(_c[j] &gt;&gt; 1); &#125; LL ans=fac[s]; for(int j=0;j&lt;26;j++) if(_c[j]&gt;0)&#123; // cout&lt;&lt;j&lt;&lt;" "&lt;&lt;_c[j]&lt;&lt;endl; ans=ans*inv[_c[j]&gt;&gt;1]%MOD; &#125; return rs==0?ans:(ans*rs%MOD);&#125;int main()&#123; scanf("%s",s+1); int len=strlen(s+1); fac[0]=1; for(int i=1;i&lt;=len+3;i++)fac[i]=(fac[i-1]*i)%MOD; inv[len+3]=qpow(fac[len+3],MOD-2); for(int i=len+2;i&gt;=0;i--)inv[i]=inv[i+1]*(i+1)%MOD; for(int i=1;i&lt;=len;i++)&#123; for(int j=0;j&lt;26;j++)cnt[i][j]=cnt[i-1][j]; cnt[i][s[i]-'a']++; &#125; cin&gt;&gt;q; while(q--)&#123; int l,r;cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;solve(l,r)&lt;&lt;endl; &#125; return 0;&#125; The Strange Function 给一个整数（可负）序列 [a1,a2,…,an][a_1,a_2,\dots,a_n][a1​,a2​,…,an​]，定义 f(l,r)=gcd⁡(a_l,a_l+1,…,a_r)((∑_i=lra_i)−max⁡(a_l,a_l+1,…,a_r))f(l,r)=\gcd(a\_l,a\_{l+1},\dots,a\_r)\left((\sum\_{i=l}^r a\_i)-\max(a\_l,a\_{l+1},\dots,a\_r)\right) f(l,r)=gcd(a_l,a_l+1,…,a_r)((∑_i=lra_i)−max(a_l,a_l+1,…,a_r)) 求 max⁡1≤l≤r≤nf(l,r)\max_{1\leq l \leq r \leq n} f(l,r) 1≤l≤r≤nmax​f(l,r) 1≤n≤105,∣ai∣≤1061 \leq n \leq 10^5, |a_i| \leq 10^61≤n≤105,∣ai​∣≤106 不会做。。然而可以骗分233，先模拟，这一步是 O(n2)O(n^2)O(n2)的。 一个很有用的优化是当左端点值为负数时可以直接跳过（这对答案没有贡献，显然一个起点正的更优，且答案最小是 000 ，因为 f(i,i)=0f(i,i)=0f(i,i)=0。 然后过了 22/4422/4422/44 个点，Rank80-&gt;Rank35，赚了。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int MAXN=50000;typedef long long LL;int n;int a[MAXN+3],b[MAXN+3];int gcd(int x,int y)&#123; return y?gcd(y,x%y):x;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; if(a[i]&lt;0)b[i]=-a[i]; else b[i]=a[i]; &#125; LL ans=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&lt;=0)continue; int m=a[i],g=b[i],s=a[i]; for(int j=i+1;j&lt;=n;j++)&#123; if(a[j]&gt;m)m=a[j]; if(g!=1)g=gcd(g,b[j]); s+=a[j]; if(s-m&gt;0)&#123; LL t=(LL)g*(s-m); if(ans&lt;t)ans=t; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“玲珑杯” ACM比赛 Round 23]]></title>
    <url>%2FBlog%2F2017%2F12%2F30%2F%E7%8E%B2%E7%8F%91%E6%9D%AF-r23%2F</url>
    <content type="text"><![CDATA[中文题面真是太友好了 生是脂肪的人 给定一个整数 nnn ，输出 (10n)/7(10^n)/7(10n)/7 的个位数。 其中 ∣n∣≤1018|n| \leq 10^{18}∣n∣≤1018 第一眼这不快速幂模板吗？咦，模 101010，不能做。想了换模数，然后发现不行，弃。 写完二三题才回来看，想能不能打表，结果python打完发现就是 1,4,2,8,5,71,4,2,8,5,71,4,2,8,5,7 循环。 这么简单？！（为什么弃的那么早TAT，然而一次CE，一次没开 long long，挂了两次，不淡定了。 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int a[] = &#123;1, 4, 2, 8, 5, 7&#125;;typedef long long LL;int main()&#123; int T;LL n; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; if (n &lt; 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; n -= 1; cout &lt;&lt; a[n % 6] &lt;&lt; endl; &#125; return 0;&#125; 死是脂肪的鬼 给定一个99的数独，判断该数独是否合法。 如果合法输出Yes,否则输出No。 数独当且仅当每行每列以及9个33的小方格都是1〜9的9个数才合法。 第二题数独判断，昨天作业题刚写了个数独判断233，复制粘贴。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int T;int b[20][20];bool check()&#123; for(int i=1;i&lt;=9;i++)&#123; int s1=0,s2=0; for(int j=1;j&lt;=9;j++)s1+=b[i][j],s2+=b[j][i]; if(s1!=45 || s2!=45)&#123; return false; &#125; &#125; for(int i=1;i&lt;=9;i+=3)for(int j=1;j&lt;=9;j+=3)&#123; int s=0; for(int k=0;k&lt;3;k++)for(int l=0;l&lt;3;l++)s+=b[i+k][j+l]; if(s!=45)return false; &#125; return true;&#125;int cnt[13];int main()&#123; cin&gt;&gt;T; while(T--)&#123; for(int i=1;i&lt;=9;i++)cnt[i]=0; for(int i=1;i&lt;=9;i++)&#123; for(int j=1;j&lt;=9;j++)&#123; cin&gt;&gt;b[i][j]; cnt[b[i][j]]++; &#125; &#125; bool flg=true; for(int i=1;i&lt;=9;i++)if(cnt[i]!=9)&#123;flg=false;break;&#125; if(flg)flg&amp;=check(); puts(flg?"Yes":"No"); &#125; return 0;&#125; 你居然不吃巧克力 给定一个正整数n，现在有n个石头，每个单独成一堆。 现在可以每次合并两堆石头，产生的能量为两堆石头个数的min。 你现在要将所有的石头合并成一堆，并且获得的能量最大。 输出这个最大值。 1≤n≤1071\leq n \leq 10^71≤n≤107 最后一次尽量平均即可。复杂度 O(log⁡2n)O(\log_2 n)O(log2​n) S(n)={0,if n&lt;=1⌊n/2⌋+2S(⌊n/2⌋),n is even⌊n/2⌋+S(⌊n/2⌋)+S(n−⌊n/2⌋),n is oddS(n)=\begin{cases} 0, &amp; \text{if $ n&lt;=1 $}\\ \lfloor n/2 \rfloor + 2S(\lfloor n/2 \rfloor), &amp; \text{n is even}\\ \lfloor n/2 \rfloor + S(\lfloor n/2 \rfloor)+S(n-\lfloor n/2 \rfloor), &amp; \text{n is odd}\\ \end{cases} S(n)=⎩⎪⎨⎪⎧​0,⌊n/2⌋+2S(⌊n/2⌋),⌊n/2⌋+S(⌊n/2⌋)+S(n−⌊n/2⌋),​if n&lt;=1n is evenn is odd​ 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int solve(int n)&#123; if(n&lt;=1)return 0; if(n&amp;1)&#123; return (n&gt;&gt;1)+solve(n&gt;&gt;1)+solve(n-(n&gt;&gt;1)); &#125; else&#123; return (n&gt;&gt;1)+(solve(n&gt;&gt;1)&lt;&lt;1); &#125;&#125;int main()&#123; int T;cin&gt;&gt;T; while(T--)&#123; int n;cin&gt;&gt;n; cout&lt;&lt;solve(n)&lt;&lt;endl; &#125; return 0;&#125; 别不好意思，都是脂肪的人 求 数据保证答案是一个有理数，求出模 109+710^9+7109+7 意义下的值。 有点意思的一道题。 首先转化一下，计算 每一项的出现次数，即 x1+x2+⋯+xn=tx_1+x_2+\dots+x_n=tx1​+x2​+⋯+xn​=t 的整数解的数量（可为0），这一步是经典组合计数问题，答案为 (n−1+tn−1)\binom{n-1+t}{n-1}(n−1n−1+t​)。然后就有 原式=∑t=0+∞(n−1+tn−1)(1k)t∗t\text{原式}=\sum_{t=0}^{+ \infty} \binom{n-1+t}{n-1}(\frac{1}{k})^t*t 原式=t=0∑+∞​(n−1n−1+t​)(k1​)t∗t 关于二项式系数有以下恒等式（n≥0n \geq 0n≥0）： 1(1−z)n+1=∑k=0+∞(n+kn)zk\frac{1}{(1-z)^{n+1}}=\sum_{k=0}^{+\infty} \binom{n+k}{n} z^k (1−z)n+11​=k=0∑+∞​(nn+k​)zk 注意到此题中求和项中多了一个 ttt，那么对上述恒等式左右求导，由幂级数性质有 (n+1)(1−z)−(n+2)=∑k=0+∞(n+kn)zk−1∗k(n+1)(1-z)^{-(n+2)}=\sum_{k=0}^{+\infty} \binom{n+k}{n} z^{k-1}*k (n+1)(1−z)−(n+2)=k=0∑+∞​(nn+k​)zk−1∗k 左右再乘上 zzz，就和我们要求的式子形式相同了。 z∗(n+1)(1−z)−(n+2)=∑k=0+∞(n+kn)zk∗kz*(n+1)(1-z)^{-(n+2)}=\sum_{k=0}^{+\infty} \binom{n+k}{n} z^k*k z∗(n+1)(1−z)−(n+2)=k=0∑+∞​(nn+k​)zk∗k 故原式等于 zn(1−z)−(n+1)zn(1-z)^{-(n+1)}zn(1−z)−(n+1) ，其中 z=1/kz=1/kz=1/k。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const LL MOD=1e9+7;LL T,n,k;LL qpow(LL a,LL n)&#123; LL ans=1; while(n)&#123; if(n&amp;1)ans=ans*a%MOD; a=a*a%MOD; n&gt;&gt;=1; &#125; return ans;&#125;inline LL inv(LL x)&#123; return qpow(x,MOD-2);&#125;int main()&#123; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;n&gt;&gt;k; LL z=inv(k); LL t=inv((MOD+1-z)%MOD); LL ans=z*n%MOD*qpow(t,n+1)%MOD; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C程序设计语言]]></title>
    <url>%2FBlog%2F2017%2F12%2F25%2FC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[书籍名：《C程序设计语言（第二版）》 第二章 枚举 enum id{A=1,B=2,...} 字符串支持连接 &quot;abc&quot; &quot;def&quot;=&quot;abcdef&quot; ctype 中的函数与字符表无关 使用 unsigned 的变量在隐式转换时和具体实现有关要十分注意，可能不是预期的。 float 不会自动提升为 double 伪随机数算法 [0,32767][0,32767][0,32767] 的伪随机整数 123456unsigned long int _next=1;int rand()&#123; _next=_next*1103515245+12345; return (unsigned int)(_next/65536)%32768;&#125;void srand(unsigned int seed)&#123;_next=seed;&#125; 逗号表达式从左到右求值，最右侧的表达式为其结果值。函数参数中的逗号不是逗号表达式，C语言没有定义其运算顺序 对于一个运算，左右表达式的运算先后是不确定的。 第三章 Shell-Sort 123456void shellsort(int v[],int n)&#123; for(int gap=n&gt;&gt;1;gap;gap&gt;&gt;=1) for(int i=gap;i&lt;n;i++) for(int j=i-gap;j&gt;=0 &amp;&amp; v[j]&gt;v[j+gap];j-=gap) swap(v[j],v[j+gap]);&#125; 第四章 external,internal 关键字修饰变量 register 关键字，寄存器变量地址不可访问 static 关键字修饰全局变量，使变量限定在当前编译文件中 预处理 宏定义 行末使用 \ 使用多行定义 undef 取消宏定义 替换文本中 #加在参数名前，则将会生成和参数书写完全相同的字符串 1#define debug(expr) printf(#expr " = %g\n",expr) ## 运算符 12#define paste(a,b) a ## bpaste(name,1) =&gt; name1 条件 #if #endif #elif #else #ifdef = #if defined id #ifndef = #if !defined id #line constval [&quot;filename&quot;] #error ... #praga ... 第五章 void* 作为通用指针 指针实现数组一般快于下标实现数组 指针支持和整数加减，与指针相减和比较运算（位置比较） 数组和指针不完全等价，数组本身不可变，但指针可以 12345void strcpy(char* s,char *t)&#123; while(*s++=*t++);&#125;*p++=val;//pushval=*--p;//pop 以下表达等价 123f(int c[2][13])f(int c[][13])f(int (*c)[13]) 第六章 union 类型：同一起点，不同类型变量，自动对齐，只能对第一个元素初始化 位字段：二进制标志位集合，后面的数字指定位长，仅能使用 int，不支持 &amp; 1234struct&#123; unsigned int a:1; unsigned int b:1;&#125;flgs; 第七章 exit(exitcode) printf 函数格式化：%? ? 表示转换说明 - 左对齐 数字 最小字段宽度或精度 . 用于区分最小字段宽度和精度 h/l 整数作为 short/long d/i 十进制整数 o 无符号八进制整数 x/X 无符号十六进制整数，指定大小写 u 无符号十进制整数 c 字符 f double 十进制小数 e/E double 十进制小数 科学记数法 g/G double 十进制小数 根据指数决定使用哪一种表示方式 p void* 类型 使用 * 指定宽度或精度，将使用下一参数（int）得到 变长参数 123456789#include &lt;stdarg.h&gt;void f(char *a,...)&#123; va_list ap; va_start(ap,fmt); for(char* p=fmt;*p;p++)&#123; &#125; va_end(ap);&#125; scanf 函数 返回成功赋值的个数，文件结尾返回 EOF 文件 123456789101112131415161718FILE* fp=fopen(name,mode="r[+]","w[+]","a[+]"[,"b"])//以下是宏而不是函数int getc(FILE *fp);int putc(int c,FILE* fp)=c;fscanf(FILE* fp,...)fprintf(FILE* fp,...)//清空缓冲区并关闭文件int fclose(FILE *fp)int fflush(FILE *fp)int ferror(FILE *fp)int feof(FILE *fp)char* fgets(char*line,int maxvalue,FILE *fp)=success? line:NULL;char* fputs(char*line,FILE *fp)=success? line:EOF;fgetc,fputcint ungetc(int c,FILE *fp)=success?c:EOF; //写回一个字符，只能接受一个int remove(const char* filename);//删除文件，成功返回0int rename(const char* filename);//重命名文件，成功返回0FILE* tmpfile();//wb+创建临时文件 size_t fread(void*ptr,size_t size,size_t nobj,FILE *stream) 读取最多nobj个长度为size的对象，并保存到ptr数组中，返回读取到的个数。 size_t fwrite(const void*ptr,size_t size,size_t nobj,FILE *stream) 从ptr数组读取nobj个长度为size的对象，并输出，返回输出的个数。 int fseek(FILE* stream, long offset,int origin) 从origin偏移offset个位置。origin=SEEK_SET,SEEK_CUR,SEEK_END，文本流只能是offest只能是0或ftell得到的值。 long ftell(FILE *stream) 得到当前位置，错误返回-1L void rewind(FILE *stream) 回到起点，清除错误状态 int fgetpos(FILE *stream,fpos_t *pos) 记录当前位置到pos int fsetpos(FILE *stream,const fpos_t *pos) 标准文件指针 stdin,stdout,stderr 字符串函数 strcat(s,t) strncat(s,t,n) strcmp(s,t) strncmp(s,t,n) strcpy(s,t) strncpy(s,t,n) strlen(s) strchr(s,c) 正向查找，返回指针 strrchr(s,c) 反向查找，返回指针 memcpy(s,t,n) memmove(s,t,n) memcmp(s,t,n) memchr(s,c,n) memset(s,c,n) 更多函数 void* malloc(size_t n) n字节长度 void* calloc(size_t n,size_t size) n个指定字节长度元素的空间 free(p) 仅限使用上面两个函数申请的空间 ldexp(x,n) =x∗2n=x*2^n=x∗2n frexp(x,int* exp) x=a∗2nx=a*2^nx=a∗2n，其中 a∈[1/2,1]a \in [1/2,1]a∈[1/2,1]，返回a，exp=n modf(x,double *ip) 返回小数部分，ip=整数部分，符号均和x相同 fmod(x,y) 浮点余数 double atof(char*) int atoi(char*) long atol(char*) abort() ateexit(void (*func)(void)) 登记一个程序正常终止时调用的函数]]></content>
      <categories>
        <category>Readings</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iExpr 反馈收集]]></title>
    <url>%2FBlog%2F2017%2F12%2F25%2FiExpr-%E5%8F%8D%E9%A6%88%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[请在评论区留下建议和反馈，谢谢。]]></content>
      <categories>
        <category>Designs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牛顿迭代法]]></title>
    <url>%2FBlog%2F2017%2F12%2F24%2F%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[伽罗瓦云：五次及以上多项式方程没有根式解。但面对生活中求解各种复杂方程的真实需求，是否束手无策？非也，今用牛顿迭代法高效求解方程的近似根。本文介绍了牛顿迭代法的推导和其计算机实现，并使用牛顿迭代法实现了开方等运算。 牛顿迭代法 定义 我们已知：微分是曲线的线性逼近。 对于二阶连续可导函数 y=f(x)y=f(x)y=f(x) ，设 rrr是 f(x)=0f(x)=0f(x)=0 的根。对曲线上的任意一点 A(x0,y0)A(x_0,y_0)A(x0​,y0​) ，作微分 y′=f′(x)dxy&#x27;=f&#x27;(x) \text{d}xy′=f′(x)dx, 交 xxx 轴于一点 (x1,0)(x_1,0)(x1​,0) ，如下图所示，称 x1x_1x1​ 为 rrr 的一次近似值。 注意到x1x_1x1​与函数的零点仍有一段距离， 过 x1x_1x1​ 作 xxx 轴垂线， 交 y=f(x)y=f(x)y=f(x) 于B(x1,y1)B(x_1,y_1)B(x1​,y1​) ， 继续作微分 y′=f′(x1)dxy&#x27;=f&#x27;(x_1)\text{d}xy′=f′(x1​)dx ， 交 xxx 轴于 (x2,0)(x_2,0)(x2​,0) ， 称 x2x_2x2​ 为 rrr 的二次近似值。 如下图，此时 x2x_2x2​ 与 rrr 更加接近。 重复上述过程，经过50次迭代，得下图. 此时第50次近似值已经十分接近 rrr 。 定义： 设二阶连续可导函数 y=f(x)y=f(x)y=f(x)，rrr 是 f(x)=0f(x)=0f(x)=0 的根，选取 x0x_0x0​ 作为 rrr 的初始近似值，过点 (x0,f(x0))(x_0,f(x_0))(x0​,f(x0​)) 做曲线 y=f(x)y=f(x)y=f(x) 的微分 LLL, 求出 LLL 与 xxx 轴交点的横坐标 x1=x0−f(x0)f′(x0)x_1=x_0-\frac{f(x_0)}{f&#x27;(x_0)}x1​=x0​−f′(x0​)f(x0​)​，称 x1x_1x1​ 为 rrr 的一次近似值。过点(x1,f(x1))(x_1,f(x_1))(x1​,f(x1​)) 做曲线 y=f(x)y=f(x)y=f(x) 的切线，并求该切线与x轴交点的横坐标 x2=x1−f(x1)f′(x1)x_2=x_1-\frac{f(x_1)}{f&#x27;(x_1)}x2​=x1​−f′(x1​)f(x1​)​，称 x2x_2x2​ 为 rrr 的二次近似值。重复以上过程，得 rrr 的近似值序列，其中 xn+1=xn−f(xn)f′(xn)x_{n+1}=x_n-\frac{f(x_n)}{f&#x27;(x_n)}xn+1​=xn​−f′(xn​)f(xn​)​ ，称为 rrr 的 n+1n+1n+1 次近似值，上式称为 牛顿迭代序列。 收敛条件 关于牛顿法的局部收敛性，我们有如下定理： 定理：设 x^\* 是方程 f(x)=0f(x)=0f(x)=0 的根，fff 在某个包含 x^\* 为内点的区间内足够光滑，且 f′(x)≠0f&#x27;(x) \ne 0f′(x)≠0。那么存在 x^\* 的一个邻域 N(x^\*)=[x^\*-\delta,x^\*+\delta]，使得对于任意 x_0 \in N(x^\*)，牛顿法产生的迭代序列以不低于二阶的收敛速度收敛于解 x^\*。 证明： 牛顿法是对应于函数 ϕ(x)=x−f(x)f′(x)\phi(x)=x-\frac{f(x)}{f&#x27;(x)}ϕ(x)=x−f′(x)f(x)​ 的不动点迭代。我们有 ϕ′(x)=f(x)f′′(x)[f′(x)]2\phi&#x27;(x)=\frac{f(x)f&#x27;&#x27;(x)}{[f&#x27;(x)]^2} ϕ′(x)=[f′(x)]2f(x)f′′(x)​ 若 f′(x)≠0f&#x27;(x)\ne 0f′(x)≠0，则有 \phi'(x^\*)=0。因此，牛顿迭代法是局部收敛的。 和不动点收敛类似，对于牛顿法迭代，我们有 xk+1−x∗=ϕ(xk)−ϕ(x∗)=ϕ(x∗)+ϕ′(x∗)(xk−x∗)+ϕ′′(ξk)2(xk−x∗)2−ϕ(x∗)x_{k+1}-x^*=\phi(x_k)-\phi(x^*)=\phi(x^*)+\phi&#x27;(x^*)(x_k-x^*)+\frac{\phi&#x27;&#x27;(\xi_k)}{2}(x_k-x^*)^2-\phi(x^*) xk+1​−x∗=ϕ(xk​)−ϕ(x∗)=ϕ(x∗)+ϕ′(x∗)(xk​−x∗)+2ϕ′′(ξk​)​(xk​−x∗)2−ϕ(x∗) =ϕ′′(ξk)2(xk−x∗)2=\frac{\phi&#x27;&#x27;(\xi_k)}{2}(x_k-x^*)^2 =2ϕ′′(ξk​)​(xk​−x∗)2 式中，ξk\xi_kξk​ 位于 xkx_kxk​ 和 x^\* 之间。因此 lim⁡k→+∞∣xk+1−x∗∣∣xk−x∗∣2=lim⁡k→+∞∣ϕ′′(ξk)∣2=∣ϕ′′(x∗)∣2\lim_{k\rightarrow +\infty} \frac{|x_{k+1}-x^*|}{|x_k-x^*|^2}=\lim_{k \rightarrow + \infty} \frac{|\phi&#x27;&#x27;(\xi_k)|}{2}= \frac{|\phi&#x27;&#x27;(x^*)|}{2} k→+∞lim​∣xk​−x∗∣2∣xk+1​−x∗∣​=k→+∞lim​2∣ϕ′′(ξk​)∣​=2∣ϕ′′(x∗)∣​ 计算机实现 说明 首先我们的目标是近似求解函数的根。 由于牛顿迭代法迭代过程只限于一阶导数， 我们可以使用差分的方式来近似计算某点导数值： f′(x)=f(x+eps)−f(x)epsf&#x27;(x)=\frac{f(x+eps)-f(x)}{eps} f′(x)=epsf(x+eps)−f(x)​ 其中的 epsepseps 取决于我们对最终解精度的要求。 进而，我们由上一节中牛顿迭代公式有： xn+1=xn−f(xn)f′(xn)x_{n+1}=x_n-\frac{f(x_n)}{f&#x27;(x_n)} xn+1​=xn​−f′(xn​)f(xn​)​ 注意到 lim⁡n→+∞f(xn)=0\lim_{n \rightarrow +\infty} f(x_n)=0limn→+∞​f(xn​)=0 ， 迭代最终收敛，则当我们迭代到 ∣f(xn)∣&lt;eps|f(x_n)|&lt;eps∣f(xn​)∣&lt;eps 时就可以退出迭代， 此时的 xnx_nxn​ 即为近似解。 注：在由于计算机内部对实数的存储是有误差的，所以对于 ϵ\epsilonϵ 的选取应格外小心。 Python 实现 12345678910def diff(f,x): return (f(x+eps)-f(x))/epsdef getZero(f,x0): n=0 s=x0 while True: s=s-f(s)/diff(f,s) n=n+1 if math.fabs(f(s))&lt;eps: return (s,n) getZero(f,x0)getZero(f,x_0)getZero(f,x0​) 函数接受一个函数 fff ，和迭代起点 x0x_0x0​ ϵ\epsilonϵ 即 epsepseps 为解的精度 nnn 为迭代次数 sss 为最终的解值 使用计算机求平方根 我们可以使用上面的代码求解平方根。 首先求解平方根即求函数 f(x)=x2−af(x)=x^2-af(x)=x2−a 的零点。 调用以上函数即 123f=lambda x: x**2-ax, n=getZero(f,x0)print(x,n,f(x)) 我们取 ϵ=10−15,a=2,x0=10\epsilon=10^{-15},a=2,x_0=10ϵ=10−15,a=2,x0​=10 时，程序输出 11.4142135623730951 18 4.440892098500626e-16 说明我们得到的近似解为 2≈1.4142135623730951\sqrt{2} \approx 1.41421356237309512​≈1.4142135623730951 ，迭代了 181818 次， 此处的 f(xn)=4.440892098500626∗10−16f(x_n)=4.440892098500626*10^{-16}f(xn​)=4.440892098500626∗10−16，可见 ∣f(xn)∣&lt;10−15=ϵ|f(x_n)|&lt;10^{-15}=\epsilon∣f(xn​)∣&lt;10−15=ϵ，满足精度要求。 接下来我们使用系统自带的 求平方根函数 求值，其结果为 11.4142135623730951 由此可见我们使用牛顿迭代法求得的近似解已与系统提供的求根函数精度相等，能满足一般的需求。 较复杂函数的零点近似求解 接下来以一个较复杂函数 f(x)=cos⁡((2−sin⁡(x))arctan⁡(x))f(x)=\cos((2-\sin(x))^{\arctan(x)}) f(x)=cos((2−sin(x))arctan(x)) 为例演示函数零点的求解过程。 此函数在 x=0x=0x=0 附近的图像如下： 为求出函数在 x=2x=2x=2 附近的零点， 我们取 ϵ=10−10,x0=2\epsilon=10^{-10},x_0=2ϵ=10−10,x0​=2 ，程序输出 12.567793875101797 5 -1.1263042511219229e-14 则经过 555 次迭代，我们得到近似解 2.5677938751017972.5677938751017972.567793875101797。 进一步的，我们可以通过其具体迭代过程发现，迭代的步长缩小得很快，这符合之前的预期： x0=2x_0=2 x0​=2 x1=3.048910600444615x_1=3.048910600444615 x1​=3.048910600444615 x2=2.5508408648839507x_2=2.5508408648839507 x2​=2.5508408648839507 x3=2.5679378839996416x_3=2.5679378839996416 x3​=2.5679378839996416 x4=2.567793884737295x_4=2.567793884737295 x4​=2.567793884737295 x5=2.567793875101797x_5=2.567793875101797 x5​=2.567793875101797 总结 使用牛顿迭代法，我们可以快速近似计算满足收敛条件的函数的零点。 这种方法解决了很多非线性方程组的求根问题，简化了许多工程问题的计算。 参考资料：同济大学计算数学教研室《现代数值计算》（人民邮电出版社）]]></content>
      <categories>
        <category>Studies</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛法及扩展]]></title>
    <url>%2FBlog%2F2017%2F12%2F23%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E5%8F%8A%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[以下代码中的定义： mindiv[i]: i的最小质因子 phi[i]: 欧拉函数i的值 mindivq[i]: i的最小质因子的个数 d[i]: i的约数个数 sumd[i]: i的约数和 miu[i]: 莫比乌斯函数i的值 inv[i]: i在mod n意义下的乘法逆元 标准筛法 欧拉筛法，可以保证每个数只被自己最小的质因子筛去，时间复杂度O(n) 两种等价实现 易于理解版： 12345678910void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i]) mindiv[i]=pris[++cnt]=i; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)break; &#125; &#125;&#125; 又短又快版（避免了取模运算）：（待更新） 12345678910void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i]) mindiv[i]=pris[++cnt]=i; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; if(i%pris[j]==0)break; mindiv[k]=pris[j]; &#125; &#125;&#125; 扩展：求积性函数 积性函数定义：对于一个数论函数 f(x)f(x)f(x)，满足：若 gcd(a,b)=1gcd(a,b)=1gcd(a,b)=1 ，则 f(ab)=f(a)f(b)f(ab)=f(a)f(b)f(ab)=f(a)f(b) 的函数 fff 。 由于这个性质，我们可以在筛法的同时求出积性函数的值 先看几个简单的积性函数： id函数 定义 id(i)=iid(i)=iid(i)=i ，显然满足积性。 这就不用筛了，直接得到值 e函数 又称单位函数，定义 e(n)={1,if n=10,otherwisee(n)=\begin{cases} 1, &amp; \text{if $ n=1 $}\\ 0, &amp; \text{otherwise} \end{cases} e(n)={1,0,​if n=1otherwise​ phi函数 欧拉函数，很有用，可以用来求逆元。 定义 ϕ(i)=∑j=1ie(gcd(j,i))\phi(i)=\sum_{j=1}^ie(gcd(j,i)) ϕ(i)=j=1∑i​e(gcd(j,i)) 即 [1,n][1,n][1,n] 中，与 nnn 互质的数的数量 易得对于质数，phi(p)=p−1phi(p)=p-1phi(p)=p−1， 对于合数有以下公式： n=∏i=1rpiqin=\prod_{i=1}^r p_i^{q_i} n=i=1∏r​piqi​​ ϕ(n)=n∗(1−1/p1)∗(1−1/p2)∗...\phi(n)=n*(1-1/p_1)*(1-1/p_2)*... ϕ(n)=n∗(1−1/p1​)∗(1−1/p2​)∗... 将n带入可得 phi(n)=∏i=1r(pi−1)∗piqi−1phi(n)=\prod_{i=1}^r(p_i-1)*p_i^{q_i-1} phi(n)=i=1∏r​(pi​−1)∗piqi​−1​ 这就很容易发现它的积性性质 用筛法怎么求呢？ 稍微改一下就行了： 12345678910111213141516void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; phi[i]=i-1; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; phi[k]=phi[i]*pris[j]; break; &#125; phi[k]=phi[i]*(pris[j]-1); &#125; &#125;&#125; 为什么呢？ 对于 i%pris[j]!=0 的项，它的最小质因子一定是 pris[j] ，则由积性函数性质可得 phi[k]=phi[i]*phi[pris[j]] ，其中phi[pris[j]]=pris[j]-1 对于 i%pris[j]==0 的项，则说明 pris[j] 已经在 i 中已经出现了，而且是最小的，观察 ϕ\phiϕ 函数的计算式，可知此时应乘 pris[j] 最小质因数的指数 这个就很简单了： 12345678910111213141516void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; mindivq[i]=1; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; mindivq[k]=mindivq[i]+1; break; &#125; mindivq[k]=1; &#125; &#125;&#125; 约数个数 首先约数个数如何求？ 分解质因数，得到 n=∏i=1rpiqin=\prod_{i=1}^r p_i^{q_i} n=i=1∏r​piqi​​ 则其 约数个数 =∏i=1r(qi+1)=\prod_{i=1}^r(qi+1) =i=1∏r​(qi+1) 这个结论由乘法原理易得，每个质因子有 qi+1qi+1qi+1 种选法。 积性就不证了，比较显然。 怎么求呢？ 观察筛法的过程， i 是质数时或 i%pris[j]!=0 时都比较容易，主要是 i%pris[j]==0 时需要考虑好。 下面来分析一下： 关键在于如何由 d(i) 转移到 d(i*pris[j]) 首先筛法保证了 pris[j] 一定是最小质因子，那么由于 i%pris[j]==0 ，则意味着最小质因子的指数会 +1+1+1，这一点在上面的 mindivq 求解过程中也体现了。 +1+1+1 会导致什么？ 很自然会想到 d(k)=d(i)∗(mindivq[k]=mindivq[i]+1)+1mindivq[i]+1d(k)=d(i)*\frac{(mindivq[k]=mindivq[i]+1)+1}{mindivq[i]+1} d(k)=d(i)∗mindivq[i]+1(mindivq[k]=mindivq[i]+1)+1​ 就是这样。 12345678910111213141516171819void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; mindivq[i]=1; d[i]=2; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; mindivq[k]=mindivq[i]+1; d[k]=d[i]/(mindivq[i]+1)*(mindivq[k]+1); break; &#125; mindivq[k]=1; d[k]=d[i]*d[pris[j]]; &#125; &#125;&#125; 约数和 约数和又如何求？ 分解质因数，得到 n=∏i=1rpiqin=\prod_{i=1}^r p_i^{q_i} n=i=1∏r​piqi​​ 则其 约数和 =∏i=1r∑j=0qipij=\prod_{i=1}^r\sum_{j=0}^{q_i} p_i^j =i=1∏r​j=0∑qi​​pij​ 看起来也是比较显然，我们直接讨论如何利用筛法来求： 依然是利用和上面的类似思路： 只讨论 i%pris[j]==0 的情况： 需要除以 ∑n=0mindivq[i](pris[j])n\sum_{n=0}^{mindivq[i]}(pris[j])^n∑n=0mindivq[i]​(pris[j])n 再乘以 ∑n=0mindivq[k](pris[j])n\sum_{n=0}^{mindivq[k]}(pris[j])^n∑n=0mindivq[k]​(pris[j])n 其中 mindivq[k]=mindiv[i]+1mindivq[k]=mindiv[i]+1mindivq[k]=mindiv[i]+1 这样开两个辅助数组记录 t1[i]=∑n=0mindivq[i]pris[j]nt1[i]=\sum_{n=0}^{mindivq[i]}pris[j]^n t1[i]=n=0∑mindivq[i]​pris[j]n t2[i]=(mindiv[i])mindivq[i]t2[i]=(mindiv[i])^{mindivq[i]} t2[i]=(mindiv[i])mindivq[i] 就可以做了： 12345678910111213141516171819202122void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; sumd[i]=1+i; t1[i]=1+i; t2[i]=i; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; t2[k]=t2[i]*pris[j]; t1[k]=t1[i]+t2[k]; sumd[k]=sumd[i]/t1[i]*t1[k]; break; &#125; sumd[k]=sumd[i]*sumd[pris[j]]; t1[k]=1+pris[j]; t2[k]=pris[j]; &#125; &#125;&#125; miu函数 莫比乌斯函数，定义 μ(n)={1,if n=10,if is square free numbern(−1)质因数个数otherwise\mu(n)=\begin{cases} 1, &amp; \text{if $ n=1 $}\\ 0, &amp; \text{if $n$ is square free number}\\ (-1)^{\text{质因数个数}}&amp; \text{otherwise} \end{cases} μ(n)=⎩⎪⎨⎪⎧​1,0,(−1)质因数个数​if n=1if n is square free numberotherwise​ 用筛法求也很简单： 12345678910111213141516void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; miu[i]=-1; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; miu[k]=0; break; &#125; miu[k]=-miu[i]; &#125; &#125;&#125; 乘法逆元 由求逆元的欧拉定理方法易知乘法逆元也是积性的，而且有一个很优美的性质：它是完全积性的。 所以求它变得很简单： inv[p]=pphi(n)−1modninv[p]=p^{phi(n)-1}\mod n inv[p]=pphi(n)−1modn inv[k]=inv[i]∗inv[pris[j]]if gcd(k,n)=1inv[k]=inv[i]*inv[pris[j]] \quad\text{if } gcd(k,n)=1 inv[k]=inv[i]∗inv[pris[j]]if gcd(k,n)=1 然而乘法逆元有一个递推的方法，更加简单： 首先逆元满足以下等式（定义）： inv[P mod i]∗(P mod i)=1inv[P\text{ mod }i]*(P\text{ mod }i)=1 inv[P mod i]∗(P mod i)=1 将P % i展开： inv[P mod i]∗(P−⌊P/i⌋∗i)=1inv[P\text{ mod }i]*(P-\lfloor P/i \rfloor *i)=1 inv[P mod i]∗(P−⌊P/i⌋∗i)=1 进一步展开： inv[P mod i]∗i∗(−⌊P/i⌋)=1inv[P\text{ mod }i]*i*(-\lfloor P/i \rfloor)=1 inv[P mod i]∗i∗(−⌊P/i⌋)=1 会发现一个神奇的等式： i∗(−⌊P/i⌋)∗(inv[P mod i])=1i*(-\lfloor P/i \rfloor)*(inv[P\text{ mod }i])=1 i∗(−⌊P/i⌋)∗(inv[P mod i])=1 此时 (−⌊P/i⌋)∗(inv[P mod i])(-\lfloor P/i \rfloor)*(inv[P\text{ mod }i])(−⌊P/i⌋)∗(inv[P mod i]) 就是 iii 的逆元！ 总结 线性欧拉筛法简洁，积性函数性质优美，充分结合才能发挥更大的效果。同时又要注意到不同函数的性质，用筛法求积性函数的本质是根据积性函数的定义和运算式，利用筛法的特点，构造合适的转移方法。]]></content>
      <categories>
        <category>Studies</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[码题助手]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2F%E7%A0%81%E9%A2%98%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[感谢来读，语文不好，表达有问题的还请指出。以下这段只是我的吐槽，可以跳过。 这个“助手”是这样来的：写题的时候，用了vscode后根本无法忍受devcpp的“丑陋”，然而vscode对C++的编译支持的并不好，一时间陷入两难。最终决定写个程序简化编译等做题中常用的功能，现在配合vscode十分舒服。 介绍 名称：acm（因为是码题用的） 功能： 配置外部编译器编译 使用代码模板 自动输入输出 自动测量程序运行时间与使用内存（准确度一般） 自动使用用户提供的数据判题（具体见后文）。 版本：v1.0 作者：Stardust D.L.（Liang） 支持系统：原生Windows 10，Mac OS 10+ 下载 Windows 10 Mac OS 个人使用体会 我比较习惯编辑器+命令行的写程序方式，然后每次编译都要写 g++ a.cpp -o a 这么长，很烦，然后就写了这么个简化命令的程序。不过对于习惯GUI的人，可能体验上还是不如GUI。 觉得最好用的是 check 功能，每次写题，先把输入和标准输出打进去，然后改完代码直接check，就能知道这组数据过没过，比以前每次重新输入，目测比对方便多了（已经习惯这种方式了）。 不过怎么着也是个自己用的工具，写的还很简单，不过平常写题用着还是比较方便的。发出来要是能帮到人就很开心了。 至于这个怎么用。。。看看下面的就好了，比C++简单多了（233 另外一些具体内容我没写，（懒 使用 第0步 解压就好了 如果需要请将解压目录加入系统环境变量(*) 请在使用前先将命令行当前目录指定到码题的工作目录（cd myfolder） 第1步：准备 命令行调用 acm（如果您已完成(*)） 如果当前目录不存在acm环境，会显示白色字样，已存在的话会显示绿色 Loaded 字样。接下来等待输入命令 等待输入的行头可能有两种： &gt; c.cpp &gt; ：当前代码文件为c.cpp 第2步：命令介绍 调用完 init 命令就先去配置吧（第3步），配置完再开始用别的命令。 init 初始化acm环境 clear 清除acm环境 exit 退出 cls 清空命令行 reload 重新载入（设置等） build 编译当前文件 run 运行已编译的文件 br 等价于build and run new &lt;filename&gt; [-c] 新建文件，filename 请带上扩展名，这样系统会自动匹配您提供的代码模板，-c 可选，指示系统自动将此文件设置为当前文件。 kill 干掉运行中的程序（比如死循环了TAT） check 对当前代码，自动编译执行，自动输入输出，自动比对答案。（个人最满意的功能），会显示评测结果和运行时间内存等，注意这里判题是简单比对，一般是忽视行尾空格的（其实就是系统命令fc） 关于check功能 请将输入写到\.acm\input.in，标准输出写到\.acm\std.ans，然后调用check。 第3步：系统配置 这里很关键，不过也简单。 建议安装MinGW(Devcpp 自带，在安装目录的MinGW64目录下），这样下面的编译器设置就可以指定为 类似这样的 D:\MinGW\bin\g++.exe acm环境初始化后，系统会在当前目录创建隐藏文件夹.acm，介绍如下： 12345678910.acm\ templates\ 代码模板们（文件名必须是 base.扩展名） base.c 默认C代码模板 base.cpp 默认C++代码模板 input.in 输入文件 output.out 输出文件（有输出时会产生） std.ans 正确输出 checker.json 评测标准 builder.json 编译配置 config.json 系统设置 相关配置文件设置：（能看懂的我就不写了，以下给出的都是建议配置（当然系统环境不同可能会有调整），另外文件为json格式，默认无缩进，可以使用代码格式化工具加上缩进（比如vscode使用快捷键 alt+shift+F ） 重点 一般只有config.json中的 UseFileInput,UseFileOutput 改为true，builder.json的编译器指定（如果没有把 g++ 加到环境变量中的话）两处需要修改。 checker.json 1234&#123; "MemoryLimitMB": 256, "TimeLimitMS": 1000&#125; builder.json 123456789101112131415161718192021&#123; "WaitTime": 10000, //编译最大时限 "builders": [ &#123; "Key": 2,//2代表C++编译器 "Value": &#123; "Arguments": "#input -o #output", //编译参数，请用#input 代替输入，#output 代替输出，这与编译器所使用的命令格式有关 "Command": "g++"//编译器程序命令（或程序路径） &#125; &#125;, &#123; "Key": 1,//1代表C编译器 "Value": &#123; "Arguments": "#input -o #output", "Command": "gcc" &#125; &#125; ]&#125; config.json 12345678910111213141516&#123; "Templates": &#123;//代码模板设置，这里不说明了（我懒了） "CodeTemplateBase": [ &#123; "Key": 1, "Value": "\/templates\/base.c" &#125;, &#123; "Key": 2, "Value": "\/templates\/base.cpp" &#125; ] &#125;, "UseFileInput": true,//是否使用文件（input.in）自动输入 "UseFileOutput": true//是否自动输出到文件（output.out）&#125; 修改配置后一定要用reload命令重新加载，不然配置只有下次启动acm时才生效。 备注 个人感觉最佳搭配编辑器为 Visual Code，使用其内置的终端可以使得编辑与执行始终在一个界面。 可能会有Bug，使用时请留意。 谢谢使用。 本文档可能会有修改。 展望 可能以后会加上HDU，POJ自动提交功能（其实已经实现了，然而没空写细节） 理论上是能跨平台的（比如支持Linux，Mac OS），然而不同系统API不同，技术所限，暂时不支持。要是有同学会 .Net Core 还请教教我。 还有什么建议欢迎发到我邮箱。 感谢 CommandLine]]></content>
      <categories>
        <category>Designs</category>
      </categories>
      <tags>
        <tag>Apps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iExpr 编程示例与常用运行时函数]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2FiExpr-Examples%2F</url>
    <content type="text"><![CDATA[快速幂 123456789qpow=(a,n)=&gt;func( return=1, while(n&gt;=1, [ if(n%2==1,return=return*a), a=a*a, n=floor(n/2) ])) 函数极小值 12345678910eps=0.000001,fmin=&gt;(ex,x0)=&gt;func( p:=diffi(ex,x0), t:=0.3*p, while(abs(t)&gt;=eps,[ x0=x0-t, p=diffi(ex,x0), t=0.3*p]), return=x0) 笛卡尔积 12345dmul=(a,b)=&gt;func( return=[], foreach(a,x, foreach(b,y, return=cup(return,[tuple(x,y)])))) 阶乘 1234fac=(n)=&gt;func( if(n&gt;0, return=n*fac(n-1), return=1)), 冒泡排序 12345678910111213sort=(l)=&gt;func( n:=l.len(), for(i=0,i&lt;n,i=i+1, for(j=i+1,j&lt;n,j=j+1, if(val(l,i)&gt;val(l,j), [t:=val(l,i), val(l,i,val(l,j)), val(l,j,t)] ) ) ), return=l) 以下函数已有预定义函数，此为近似实现 生成 [1,2,…n] 1234range=(a,b)=&gt;func( return=[], for(i:=a,i&lt;=b,i=i+1, return=cup(return,[i]))) 转换函数 1234567select=(l,f)=&gt;func( n:=len(l), return=array(n), for(i:=0,i&lt;n,i=i+1, val(return,i,f(val(l,i))) )) 挑选函数 12345678where=(l,f)=&gt;func( return=[], foreach(l,x, if(f(x), return=return.cup([x]) ) ))]]></content>
      <categories>
        <category>Designs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iExpr 更新介绍]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2FiExpr-%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[版本 1.3 引入了 Lambda 表达式 示例：(x,y,z)=&gt;(x+y+z) 可以使用 Lambda 表达式 表示函数，如果配合 func 则能定义极为复杂的函数 我们使用 Lambda 表达式 重写了 求导和积分 的表达方式，现在的表达更加自然 diff((x)=&gt;x^2) 通过 Lambda 表达式 ，现在的函数定义和调用也有所调整。详情请见说明文档 引入了 foreach]]></content>
      <categories>
        <category>Designs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表达式计算器-iExpr]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8-iExpr%2F</url>
    <content type="text"><![CDATA[版本更新内容 介绍 个人设计的一个表达式计算器，支持以下功能 带关系运算和逻辑运算的数学表达式解析与计算 支持常见数学函数 表达式带变量运算，变量赋值运算 支持简单求导（实现十分简单，所以支持的函数很少，但很多函数可以使用伪求导），定积分求值等运算 简单逻辑表达式的解析与计算 绘制函数图象 打印真值表 使用编程方式进行一些复杂运算 系统要求：Windows 10 秋季创意者更新（16299） 制作目的为对已学习知识的实践，以使用的方便灵活为主要目标。 由于制作时间短，本程序仍存在不少Bug，详情请见备注。 目前版本仍为测试版本，稳定性不足，还请注意程序得到的结果是否正确。 如果您想反馈Bug，我是非常欢迎的，邮箱为 stardustdl@163.com 但由于是个人业余开发者，更新周期不定，Bug修复时间不定。 外观 数学表达式 逻辑表达式 函数绘图 编程页面 下载在这里 以下为使用说明。 iExpr 使用说明 本说明版本：2017.12.9 适用软件版本：iExpr 1.3 下载在这里 界面介绍 iExpr 分为四个页面，分别为数学表达式，逻辑表达式，数学表达式图像，编程页面。 表达式页面头部有表达式编辑框（回车解析，Esc取消运算），其下有两栏， 第一栏会显示表达式计算结果（如果解析失败也会将提示信息显示在这里）。 第二栏会显示表达式解析结果，可以在这里检查系统解析的表达式是否符合预期。 表达式页面主体部分会提供相关扩展功能。 您切换页面时原页面中的信息会被清空，所以请保留好您需要的信息（如输入表达式）。 表达式 基本语法 () 小括号用于区分优先级与包围函数参数 @&quot;abc&quot; 表示其中的内容(abc)为一个整体，常用来表示预定义常量（不同表达式系统中可能有不同的预定义常量表示），有时也用于被运算者独立解析的函数参数或指定变量名。 F(arg1,arg2,...) 函数格式（F 在这里包含自定义的函数以及 Lambda 表达式，关于自定义的函数 具体请见编程部分）。注：函数的运算优先级最高 a b c d 表达式支持变量表示，首字符不为数字或运算符（函数）关键字的一般都会解析为变量，但仍强烈建议使用纯字母或字母+数字的方式表示变量。 (v1,v2,...)=&gt;(expr) Lambda 表达式，可以理解为自己定义的一个自变量为 v1,v2,v3,…v1,v2,v3,\dotsv1,v2,v3,… 的函数 x.func(args) 调用函数，对于部分支持前置参数的函数，可以这样调用，其等价于 func(x,args) 集合类型表示 [1,2,a^2,5] 列表，用 [] 包围表示这是一个列表，其中元素以 , 分隔 {1,2,a^2,5} 无序不重集合，用 {} 包围表示这是一个集合，其中元素以 , 分隔 (1,2,a^2,5) 定长元组，用 () 包围表示这是一个元组，其中元素以 , 分隔 基础表达式系统 为各表达式系统的基础 运算符 =&gt; Lambda 表达式定义 . 层级调用 函数 list(l1,l2,...) 生成列表，参数中的单层集合会被展开。 tuple(l1,l2,...) 生成元组，参数中的单层集合会被展开。 set(l1,l2,...) 生成集合，参数中的单层集合会被展开。 len(l1,l2,...) 统计元素数目，参数中的单层集合会被展开。 val(l,index) 获取列表 l 中的第 index 项（从0开始计数） val(l,index，newval) 将列表 l 中的第 index 项（从0开始计数）设为 newval 数学表达式系统 以下变量除特殊标明外都默认为实数类型。 基本部分 运算符（优先级从低到高） + 加 - 减，包含取负，注意这里优先级较低，使用x-1时请写成x(-1) * 乘 / 除 % 取模 ^ 指数 函数 sin(x) 正弦函数 cos(x) 余弦函数 tan(x) 正切函数 arcsin(x) 反正弦函数 arccos(x) 反余弦函数 arctan(x) 反正切函数 log(base,val) 对数 ln(val) 自然对数 abs(x) 绝对值 round(x) 舍入到最精确的整数 ceil(x) 大于等于x的最小整数 floor(x) 小于等于x的最小整数 exp(x) e的幂次 sign(x) x的符号 常量值 e 自然对数的底数 pi 圆周率 扩展部分 运算符 这里主要扩展了关系运算和简单逻辑运算，它们的结果为0或1。 | 或 &amp; 且 == 相等 != 不等 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 函数 eval(expr,v1,v2,...) 将expr中的变量按给出的值依次赋值（字典序），然后求值 sum(expr,l,r) ∑lrexpr\sum_l^r{expr} l∑r​expr 变量自l到r（会自动转换为整数）遍历，带入expr求值（expr中应只含有一个变量），然后累加。 prod(expr,l,r) ∏lrexpr\prod_l^r{expr} l∏r​expr 变量自l到r遍历（会自动转换为整数），带入expr求值（expr中应只含有一个变量），然后累乘。 微积分部分 diff((vid)=&gt;(expr)) dexprdvid\frac{\mathrm{d}\,expr}{\mathrm{d}\,vid} dviddexpr​ 初等函数求导 diffi((vid)=&gt;(expr),x0) f(x0+step)−f(x0)step\frac{f(x_0+step)-f(x_0)}{step} stepf(x0​+step)−f(x0​)​ 使用差分计算 x0x_0x0​ 处切线斜率。默认 step=0.001 integ((x)=&gt;(expr),l,r) ∫lrexprdx\int_l^r{expr}\,\mathrm{d}\,x ∫lr​exprdx expr（单变量函数，变量名会自动选择）在 [l,r][l,r][l,r] 上的定积分模拟：精度默认值为 10−610^{-6}10−6 数论部分 gcd(int x,int y) 最大公因数 lcm(int x,int y) 最小公倍数 统计部分 min(v1,v2,...) 最小值，其中参数可以为集合类型，嵌套集合类型会被展开 max(v1,v2,...) 最大值，其中参数可以为集合类型，嵌套集合类型会被展开 total(v1,v2,...) 总和，其中参数可以为集合类型，嵌套集合类型会被展开 mean(v1,v2,...) 平均值，其中参数可以为集合类型，嵌套集合类型会被展开 集合部分 cup(v1,v2,...) ⋃vi\bigcup v_i ⋃vi​ 并集，其中参数必须为集合类型 cap(v1,v2,...) ⋂vi\bigcap v_i ⋂vi​ 交集，其中参数必须为集合类型 dif(v1,v2,...) v1∖v2∖v3∖…v_1 \setminus v2 \setminus v3 \setminus \dots v1​∖v2∖v3∖… 差集（v1-v2-v3-…），其中参数必须为集合类型 求值 在代值页面点击刷新会加载当前表达式所有有意义变量（部分变量可能会在计算中被化简掉），设置变量值后点击计算会在计算结果区显示结果。 绘图 对于单变量表达式，在图像页面可以绘制其图像。 可以使用右侧按钮或鼠标滚轮放大缩小。拖动界面可移动绘图区域。 示例 1+(2*3-5^2)/4 sum((x%2==0)*x,1,10) diffi(x=&gt;abs(x),2) 绘图例子： x^3 diffi(x=&gt;abs(x),x) integ(x=&gt;e(-x2),0,x) 逻辑表达式 运算符（优先级从低到高） -&gt; 推出 &lt;-&gt; 等价 | 或 ^ 异或 &amp; 且 ! 非 常量 true,True 真 false,False 假 求值 在代值页面点击刷新会加载当前表达式所有有意义变量（部分变量可能会在计算中被化简掉），设置变量值后点击计算会在计算结果区显示结果。 数学表达式图像部分 界面类似数学表达式部分的图像页面，但这里支持多个函数图像绘制。 解析器将会把每行解析为一个单变量函数，可以接受以下表达式 + 普通单变量表达式 x^2 + 单变量 Lambda 表达式 x=&gt;x^2 x=&gt;func(return=x^2) 这里的表达式解析基于下面将要提到的编程表达式，所以您可以使用丰富的编程函数构建复杂的函数。 左栏下方会显示所画的函数与颜色的对于关系，拖动右侧图像区域可以移动，支持滚轮缩放，但这会导致重新绘图，对于复杂函数可能需要等待绘图完成。 编程部分 此部分还不是很成熟，使用时请适当注意 支持数学表达式的代码式运算。点击上方按钮（或F5）即可运行，Esc键取消运行。如果有错误会在下方显示错误信息。 请使用如下语法（其中expr1,expr2,…是语句，注意用逗号分隔）： &gt; 此版本不再需要输入 exec 函数 123expr1,expr2,... 语句语法 赋值 12x=1,v=[1,2,3] 将指定名称变量赋值成右侧表达式的值，这里要求右侧表达式的值必须是能计算出确定值的表达式。 独立赋值 12x:=1,v:=[1,2,3] 功能和赋值语句相同，但他会在当前环境新建变量，从而隐藏掉父级的同名变量。 弱声明 1def(id,expr) 将指定名称的变量赋成右侧的表达式，这里不要求右侧表达式的值必须是常量（即可以是类似x^2这样的含变量表达式。 函数块 1func(expr1,expr2,...) 函数块会自动新定义一个名为 return 的变量（初值为 Null ），函数块的结果为依次执行 expr 后 return 的值。 过程块 1action(expr1,expr2,...) 过程块会依次执行 expr ，然后返回空值。 运行时函数 1id=(v1,v2,...)=&gt;(expr) 构建一个运行时函数，其参数名为 v1,v2,... 。内部代码为 expr，结果为计算 expr 后的结果（这里可以用 func 构建 expr ）(这里运行时函数的本质就是一个 Lambda 表达式） 与赋值类似，def 也有相对应的 redef 独立声明 调用运行时函数 1id(args) 和调用预定义函数的用法相同。 以下用法已弃用 call(fid,arg1,arg2,…) 程序控制函数 循环 1234for(begin,cond,step,expr)while(cond,expr)do(expr,cond)foreach(list,varName,expr) 条件 1if(cond,then-expr,else-expr) 更多函数 array(n,defaultVal) 生成 nnn 个元素的元组，初始值为 defaultVal （可省略，默认为空值） range(l,r) 生成 [l,r][l,r][l,r] 的整数序列 random(l,r) 生成 [l,r)[l,r)[l,r) 范围内的随机整数 sort(list,cmpFunc) 升序排序，cmp 转换函数（Lambda 表达式） select(list,transFunc) where(list,condFunc) zip(list,zipFunc) 这几个函数和函数式编程中常用的三个同名函数意义相同，具体使用请参见 更多算法和例子 例子 更多算法和例子请见 这里 基本计算 1234567exec(list=[1,2,3],def(f,x^2),s=total(list),s,diff(f,@&quot;x&quot;)) 其结果为 126(2*(x^1))*1 简单算法 快速幂计算模意义下的幂（模数较大且幂次较高时会有较大精度误差） 123456789101112131415exec(mod=13331,def(qpow,(a,n), func( return=1, while(n&gt;=1, [ if(n%2==1,return=return*a%mod), a=a*a%mod, n=floor(n/2) ]) )),call(qpow,2,15)) 备注 仍为测试版本，正在收集各式各样的Bug，已知Bug如下 绘图部分不稳定，尤其是复杂函数绘制和极大极小缩放场景 变量识别有漏洞 部分Bug将在下一版本中修复。 编程部分将有较大改动，将支持自定义函数：]]></content>
      <categories>
        <category>Designs</category>
      </categories>
      <tags>
        <tag>Apps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2FHello-World1%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
