<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性筛法及扩展]]></title>
    <url>%2FBlog%2F2017%2F12%2F23%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E5%8F%8A%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[以下代码中的定义： mindiv[i]: i的最小质因子 phi[i]: 欧拉函数i的值 mindivq[i]: i的最小质因子的个数 d[i]: i的约数个数 sumd[i]: i的约数和 miu[i]: 莫比乌斯函数i的值 inv[i]: i在mod n意义下的乘法逆元 标准筛法欧拉筛法，可以保证每个数只被自己最小的质因子筛去，时间复杂度O(n)两种等价实现易于理解版： 12345678910void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i]) mindiv[i]=pris[++cnt]=i; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)break; &#125; &#125;&#125; 又短又快版（避免了取模运算）：（待更新） 12345678910void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i]) mindiv[i]=pris[++cnt]=i; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; if(i%pris[j]==0)break; mindiv[k]=pris[j]; &#125; &#125;&#125; 扩展：求积性函数积性函数定义：对于一个数论函数 $f(x)$，满足：若 $gcd(a,b)=1$ ，则 $f(ab)=f(a)f(b)$ 的函数 $f$ 。由于这个性质，我们可以在筛法的同时求出积性函数的值先看几个简单的积性函数： id函数定义 $id(i)=i$ ，显然满足积性。这就不用筛了，直接得到值 e函数又称单位函数，定义 e(n)=\begin{cases} 1, & \text{if $ n=1 $}\\ 0, & \text{otherwise} \end{cases}phi函数欧拉函数，很有用，可以用来求逆元。定义 \phi(i)=\sum_{j=1}^ie(gcd(j,i))即 $[1,n]$ 中，与 $n$ 互质的数的数量易得对于质数，$phi(p)=p-1$，对于合数有以下公式： n=\prod_{i=1}^r p_i^{q_i}\phi(n)=n*(1-1/p_1)*(1-1/p_2)*...将n带入可得 phi(n)=\prod_{i=1}^r(p_i-1)*p_i^{q_i-1}这就很容易发现它的积性性质用筛法怎么求呢？稍微改一下就行了： 12345678910111213141516void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; phi[i]=i-1; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; phi[k]=phi[i]*pris[j]; break; &#125; phi[k]=phi[i]*(pris[j]-1); &#125; &#125;&#125; 为什么呢？ 对于 i%pris[j]!=0 的项，它的最小质因子一定是 pris[j] ，则由积性函数性质可得 phi[k]=phi[i]*phi[pris[j]] ，其中phi[pris[j]]=pris[j]-1 对于 i%pris[j]==0 的项，则说明 pris[j] 已经在 i 中已经出现了，而且是最小的，观察 $\phi$ 函数的计算式，可知此时应乘 pris[j] 最小质因数的指数这个就很简单了： 12345678910111213141516void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; mindivq[i]=1; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; mindivq[k]=mindivq[i]+1; break; &#125; mindivq[k]=1; &#125; &#125;&#125; 约数个数首先约数个数如何求？ 分解质因数，得到 n=\prod_{i=1}^r p_i^{q_i}则其 约数个数 =\prod_{i=1}^r(qi+1)这个结论由乘法原理易得，每个质因子有 $qi+1$ 种选法。积性就不证了，比较显然。 怎么求呢？ 观察筛法的过程， i 是质数时或 i%pris[j]!=0 时都比较容易，主要是 i%pris[j]==0 时需要考虑好。 下面来分析一下： 关键在于如何由 d(i) 转移到 d(i*pris[j])首先筛法保证了 pris[j] 一定是最小质因子，那么由于 i%pris[j]==0 ，则意味着最小质因子的指数会 $+1$，这一点在上面的 mindivq 求解过程中也体现了。 $+1$ 会导致什么？ 很自然会想到 d(k)=d(i)*\frac{(mindivq[k]=mindivq[i]+1)+1}{mindivq[i]+1}就是这样。 12345678910111213141516171819void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; mindivq[i]=1; d[i]=2; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; mindivq[k]=mindivq[i]+1; d[k]=d[i]/(mindivq[i]+1)*(mindivq[k]+1); break; &#125; mindivq[k]=1; d[k]=d[i]*d[pris[j]]; &#125; &#125;&#125; 约数和约数和又如何求？分解质因数，得到 n=\prod_{i=1}^r p_i^{q_i}则其 约数和 =\prod_{i=1}^r\sum_{j=0}^{q_i} p_i^j看起来也是比较显然，我们直接讨论如何利用筛法来求： 依然是利用和上面的类似思路：只讨论 i%pris[j]==0 的情况：需要除以 $\sum_{n=0}^{mindivq[i]}(pris[j])^n$再乘以 $\sum_{n=0}^{mindivq[k]}(pris[j])^n$其中 $mindivq[k]=mindiv[i]+1$这样开两个辅助数组记录 t1[i]=\sum_{n=0}^{mindivq[i]}pris[j]^nt2[i]=(mindiv[i])^{mindivq[i]}就可以做了： 12345678910111213141516171819202122void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; sumd[i]=1+i; t1[i]=1+i; t2[i]=i; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; t2[k]=t2[i]*pris[j]; t1[k]=t1[i]+t2[k]; sumd[k]=sumd[i]/t1[i]*t1[k]; break; &#125; sumd[k]=sumd[i]*sumd[pris[j]]; t1[k]=1+pris[j]; t2[k]=pris[j]; &#125; &#125;&#125; miu函数莫比乌斯函数，定义 \mu(n)=\begin{cases} 1, & \text{if $ n=1 $}\\ 0, & \text{if $n$ is square free number}\\ (-1)^{\text{质因数个数}}& \text{otherwise} \end{cases}用筛法求也很简单： 12345678910111213141516void solve(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; if(!mindiv[i])&#123; mindiv[i]=pris[++cnt]=i; miu[i]=-1; &#125; for(int j=1,k;j&lt;=cnt&amp;&amp;(k=i*pris[j])&lt;=n;j++)&#123; mindiv[k]=pris[j]; if(i%pris[j]==0)&#123; miu[k]=0; break; &#125; miu[k]=-miu[i]; &#125; &#125;&#125; 乘法逆元由求逆元的欧拉定理方法易知乘法逆元也是积性的，而且有一个很优美的性质：它是完全积性的。 所以求它变得很简单： inv[p]=p^{phi(n)-1}\mod ninv[k]=inv[i]*inv[pris[j]] \quad\text{if } gcd(k,n)=1然而乘法逆元有一个递推的方法，更加简单： 首先逆元满足以下等式（定义）： inv[P\text{ mod }i]*(P\text{ mod }i)=1将P % i展开： inv[P\text{ mod }i]*(P-\lfloor P/i \rfloor *i)=1进一步展开： inv[P\text{ mod }i]*i*(-\lfloor P/i \rfloor)=1会发现一个神奇的等式： i*(-\lfloor P/i \rfloor)*(inv[P\text{ mod }i])=1此时 $(-\lfloor P/i \rfloor)*(inv[P\text{ mod }i])$ 就是 $i$ 的逆元！ 总结线性欧拉筛法简洁，积性函数性质优美，充分结合才能发挥更大的效果。同时又要注意到不同函数的性质，用筛法求积性函数的本质是根据积性函数的定义和运算式，利用筛法的特点，构造合适的转移方法。]]></content>
      <categories>
        <category>Studies</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[码题助手]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2F%E7%A0%81%E9%A2%98%E5%8A%A9%E6%89%8B%2F</url>
    <content type="text"><![CDATA[感谢来读，语文不好，表达有问题的还请指出。以下这段只是我的吐槽，可以跳过。 这个“助手”是这样来的：写题的时候，用了vscode后根本无法忍受devcpp的“丑陋”，然而vscode对C++的编译支持的并不好，一时间陷入两难。最终决定写个程序简化编译等做题中常用的功能，现在配合vscode十分舒服。 介绍 名称：acm（因为是码题用的） 功能： 配置外部编译器编译 使用代码模板 自动输入输出 自动测量程序运行时间与使用内存（准确度一般） 自动使用用户提供的数据判题（具体见后文）。 版本：v1.0 作者：Stardust D.L.（Liang） 支持系统：原生Windows 10，Mac OS 10+ 下载 Windows 10 Mac OS 个人使用体会我比较习惯编辑器+命令行的写程序方式，然后每次编译都要写 g++ a.cpp -o a 这么长，很烦，然后就写了这么个简化命令的程序。不过对于习惯GUI的人，可能体验上还是不如GUI。 觉得最好用的是 check 功能，每次写题，先把输入和标准输出打进去，然后改完代码直接check，就能知道这组数据过没过，比以前每次重新输入，目测比对方便多了（已经习惯这种方式了）。 不过怎么着也是个自己用的工具，写的还很简单，不过平常写题用着还是比较方便的。发出来要是能帮到人就很开心了。 至于这个怎么用。。。看看下面的就好了，比C++简单多了（233另外一些具体内容我没写，（懒 使用第0步 解压就好了 如果需要请将解压目录加入系统环境变量(*) 请在使用前先将命令行当前目录指定到码题的工作目录（cd myfolder） 第1步：准备 命令行调用 acm（如果您已完成(*)） 如果当前目录不存在acm环境，会显示白色字样，已存在的话会显示绿色 Loaded 字样。接下来等待输入命令 等待输入的行头可能有两种： &gt; c.cpp &gt; ：当前代码文件为c.cpp 第2步：命令介绍调用完 init 命令就先去配置吧（第3步），配置完再开始用别的命令。 init 初始化acm环境 clear 清除acm环境 exit 退出 cls 清空命令行 reload 重新载入（设置等） build 编译当前文件 run 运行已编译的文件 br 等价于build and run new &lt;filename&gt; [-c] 新建文件，filename 请带上扩展名，这样系统会自动匹配您提供的代码模板，-c 可选，指示系统自动将此文件设置为当前文件。 kill 干掉运行中的程序（比如死循环了TAT） check 对当前代码，自动编译执行，自动输入输出，自动比对答案。（个人最满意的功能），会显示评测结果和运行时间内存等，注意这里判题是简单比对，一般是忽视行尾空格的（其实就是系统命令fc）关于check功能请将输入写到\.acm\input.in，标准输出写到\.acm\std.ans，然后调用check。 第3步：系统配置这里很关键，不过也简单。 建议安装MinGW(Devcpp 自带，在安装目录的MinGW64目录下），这样下面的编译器设置就可以指定为 类似这样的D:\MinGW\bin\g++.exe acm环境初始化后，系统会在当前目录创建隐藏文件夹.acm，介绍如下： 12345678910.acm\ templates\ 代码模板们（文件名必须是 base.扩展名） base.c 默认C代码模板 base.cpp 默认C++代码模板 input.in 输入文件 output.out 输出文件（有输出时会产生） std.ans 正确输出 checker.json 评测标准 builder.json 编译配置 config.json 系统设置 相关配置文件设置：（能看懂的我就不写了，以下给出的都是建议配置（当然系统环境不同可能会有调整），另外文件为json格式，默认无缩进，可以使用代码格式化工具加上缩进（比如vscode使用快捷键 alt+shift+F ） 重点一般只有config.json中的 UseFileInput,UseFileOutput 改为true，builder.json的编译器指定（如果没有把 g++ 加到环境变量中的话）两处需要修改。 checker.json1234&#123; "MemoryLimitMB": 256, "TimeLimitMS": 1000&#125; builder.json123456789101112131415161718192021&#123; "WaitTime": 10000, //编译最大时限 "builders": [ &#123; "Key": 2,//2代表C++编译器 "Value": &#123; "Arguments": "#input -o #output", //编译参数，请用#input 代替输入，#output 代替输出，这与编译器所使用的命令格式有关 "Command": "g++"//编译器程序命令（或程序路径） &#125; &#125;, &#123; "Key": 1,//1代表C编译器 "Value": &#123; "Arguments": "#input -o #output", "Command": "gcc" &#125; &#125; ]&#125; config.json12345678910111213141516&#123; "Templates": &#123;//代码模板设置，这里不说明了（我懒了） "CodeTemplateBase": [ &#123; "Key": 1, "Value": "\/templates\/base.c" &#125;, &#123; "Key": 2, "Value": "\/templates\/base.cpp" &#125; ] &#125;, "UseFileInput": true,//是否使用文件（input.in）自动输入 "UseFileOutput": true//是否自动输出到文件（output.out）&#125; 修改配置后一定要用reload命令重新加载，不然配置只有下次启动acm时才生效。 备注个人感觉最佳搭配编辑器为 Visual Code，使用其内置的终端可以使得编辑与执行始终在一个界面。 可能会有Bug，使用时请留意。谢谢使用。 本文档可能会有修改。 展望 可能以后会加上HDU，POJ自动提交功能（其实已经实现了，然而没空写细节） 理论上是能跨平台的（比如支持Linux，Mac OS），然而不同系统API不同，技术所限，暂时不支持。要是有同学会 .Net Core 还请教教我。 还有什么建议欢迎发到我邮箱。 感谢CommandLine]]></content>
      <categories>
        <category>Designs</category>
      </categories>
      <tags>
        <tag>Apps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iExpr 编程示例与常用运行时函数]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2FiExpr-Examples%2F</url>
    <content type="text"><![CDATA[快速幂123456789qpow=(a,n)=&gt;func( return=1, while(n&gt;=1, [ if(n%2==1,return=return*a), a=a*a, n=floor(n/2) ])) 函数极小值12345678910eps=0.000001,fmin=&gt;(ex,x0)=&gt;func( p:=diffi(ex,x0), t:=0.3*p, while(abs(t)&gt;=eps,[ x0=x0-t, p=diffi(ex,x0), t=0.3*p]), return=x0) 笛卡尔积12345dmul=(a,b)=&gt;func( return=[], foreach(a,x, foreach(b,y, return=cup(return,[tuple(x,y)])))) 阶乘1234fac=(n)=&gt;func( if(n&gt;0, return=n*fac(n-1), return=1)), 冒泡排序12345678910111213sort=(l)=&gt;func( n:=l.len(), for(i=0,i&lt;n,i=i+1, for(j=i+1,j&lt;n,j=j+1, if(val(l,i)&gt;val(l,j), [t:=val(l,i), val(l,i,val(l,j)), val(l,j,t)] ) ) ), return=l) 以下函数已有预定义函数，此为近似实现生成 [1,2,…n]1234range=(a,b)=&gt;func( return=[], for(i:=a,i&lt;=b,i=i+1, return=cup(return,[i]))) 转换函数1234567select=(l,f)=&gt;func( n:=len(l), return=array(n), for(i:=0,i&lt;n,i=i+1, val(return,i,f(val(l,i))) )) 挑选函数12345678where=(l,f)=&gt;func( return=[], foreach(l,x, if(f(x), return=return.cup([x]) ) ))]]></content>
      <categories>
        <category>Designs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iExpr 更新介绍]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2FiExpr-%E6%9B%B4%E6%96%B0%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[版本 1.3 引入了 Lambda 表达式 示例：(x,y,z)=&gt;(x+y+z) 可以使用 Lambda 表达式 表示函数，如果配合 func 则能定义极为复杂的函数 我们使用 Lambda 表达式 重写了 求导和积分 的表达方式，现在的表达更加自然 diff((x)=&gt;x^2) 通过 Lambda 表达式 ，现在的函数定义和调用也有所调整。详情请见说明文档 引入了 foreach]]></content>
      <categories>
        <category>Designs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表达式计算器-iExpr]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8-iExpr%2F</url>
    <content type="text"><![CDATA[版本更新内容 介绍个人设计的一个表达式计算器，支持以下功能 带关系运算和逻辑运算的数学表达式解析与计算 支持常见数学函数 表达式带变量运算，变量赋值运算 支持简单求导（实现十分简单，所以支持的函数很少，但很多函数可以使用伪求导），定积分求值等运算 简单逻辑表达式的解析与计算 绘制函数图象 打印真值表 使用编程方式进行一些复杂运算 系统要求：Windows 10 秋季创意者更新（16299） 制作目的为对已学习知识的实践，以使用的方便灵活为主要目标。由于制作时间短，本程序仍存在不少Bug，详情请见备注。目前版本仍为测试版本，稳定性不足，还请注意程序得到的结果是否正确。如果您想反馈Bug，我是非常欢迎的，邮箱为 stardustdl@163.com但由于是个人业余开发者，更新周期不定，Bug修复时间不定。 外观数学表达式 逻辑表达式 函数绘图 编程页面 下载在这里以下为使用说明。 iExpr 使用说明 本说明版本：2017.12.9 适用软件版本：iExpr 1.3 下载在这里 界面介绍iExpr 分为四个页面，分别为数学表达式，逻辑表达式，数学表达式图像，编程页面。 表达式页面头部有表达式编辑框（回车解析，Esc取消运算），其下有两栏， 第一栏会显示表达式计算结果（如果解析失败也会将提示信息显示在这里）。 第二栏会显示表达式解析结果，可以在这里检查系统解析的表达式是否符合预期。 表达式页面主体部分会提供相关扩展功能。 您切换页面时原页面中的信息会被清空，所以请保留好您需要的信息（如输入表达式）。 表达式 基本语法 () 小括号用于区分优先级与包围函数参数 @&quot;abc&quot; 表示其中的内容(abc)为一个整体，常用来表示预定义常量（不同表达式系统中可能有不同的预定义常量表示），有时也用于被运算者独立解析的函数参数或指定变量名。 F(arg1,arg2,...) 函数格式（F 在这里包含自定义的函数以及 Lambda 表达式，关于自定义的函数 具体请见编程部分）。注：函数的运算优先级最高 a b c d 表达式支持变量表示，首字符不为数字或运算符（函数）关键字的一般都会解析为变量，但仍强烈建议使用纯字母或字母+数字的方式表示变量。 (v1,v2,...)=&gt;(expr) Lambda 表达式，可以理解为自己定义的一个自变量为 $v1,v2,v3,\dots$ 的函数 x.func(args) 调用函数，对于部分支持前置参数的函数，可以这样调用，其等价于 func(x,args) 集合类型表示 [1,2,a^2,5] 列表，用 [] 包围表示这是一个列表，其中元素以 , 分隔 {1,2,a^2,5} 无序不重集合，用 {} 包围表示这是一个集合，其中元素以 , 分隔 (1,2,a^2,5) 定长元组，用 () 包围表示这是一个元组，其中元素以 , 分隔 基础表达式系统为各表达式系统的基础 运算符 =&gt; Lambda 表达式定义 . 层级调用 函数 list(l1,l2,...) 生成列表，参数中的单层集合会被展开。 tuple(l1,l2,...) 生成元组，参数中的单层集合会被展开。 set(l1,l2,...) 生成集合，参数中的单层集合会被展开。 len(l1,l2,...) 统计元素数目，参数中的单层集合会被展开。 val(l,index) 获取列表 l 中的第 index 项（从0开始计数） val(l,index，newval) 将列表 l 中的第 index 项（从0开始计数）设为 newval 数学表达式系统以下变量除特殊标明外都默认为实数类型。 基本部分运算符（优先级从低到高） + 加 - 减，包含取负，注意这里优先级较低，使用x^-1时请写成x^(-1) * 乘 / 除 % 取模 ^ 指数函数 sin(x) 正弦函数 cos(x) 余弦函数 tan(x) 正切函数 arcsin(x) 反正弦函数 arccos(x) 反余弦函数 arctan(x) 反正切函数 log(base,val) 对数 ln(val) 自然对数 abs(x) 绝对值 round(x) 舍入到最精确的整数 ceil(x) 大于等于x的最小整数 floor(x) 小于等于x的最小整数 exp(x) e的幂次 sign(x) x的符号 常量值 e 自然对数的底数 pi 圆周率 扩展部分运算符这里主要扩展了关系运算和简单逻辑运算，它们的结果为0或1。 | 或 &amp; 且 == 相等 != 不等 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 函数 eval(expr,v1,v2,...) 将expr中的变量按给出的值依次赋值（字典序），然后求值 sum(expr,l,r) \sum_l^r{expr}变量自l到r（会自动转换为整数）遍历，带入expr求值（expr中应只含有一个变量），然后累加。 prod(expr,l,r) \prod_l^r{expr}变量自l到r遍历（会自动转换为整数），带入expr求值（expr中应只含有一个变量），然后累乘。 微积分部分 diff((vid)=&gt;(expr)) \frac{\mathrm{d}\,expr}{\mathrm{d}\,vid}初等函数求导 diffi((vid)=&gt;(expr),x0) \frac{f(x_0+step)-f(x_0)}{step}使用差分计算 $x_0$ 处切线斜率。默认 step=0.001 integ((x)=&gt;(expr),l,r) \int_l^r{expr}\,\mathrm{d}\,xexpr（单变量函数，变量名会自动选择）在 $[l,r]$ 上的定积分模拟：精度默认值为 $10^{-6}$ 数论部分 gcd(int x,int y) 最大公因数 lcm(int x,int y) 最小公倍数 统计部分 min(v1,v2,...) 最小值，其中参数可以为集合类型，嵌套集合类型会被展开 max(v1,v2,...) 最大值，其中参数可以为集合类型，嵌套集合类型会被展开 total(v1,v2,...) 总和，其中参数可以为集合类型，嵌套集合类型会被展开 mean(v1,v2,...) 平均值，其中参数可以为集合类型，嵌套集合类型会被展开 集合部分 cup(v1,v2,...) \bigcup v_i并集，其中参数必须为集合类型 cap(v1,v2,...) \bigcap v_i交集，其中参数必须为集合类型 dif(v1,v2,...) v_1 \setminus v2 \setminus v3 \setminus \dots差集（v1-v2-v3-…），其中参数必须为集合类型 求值在代值页面点击刷新会加载当前表达式所有有意义变量（部分变量可能会在计算中被化简掉），设置变量值后点击计算会在计算结果区显示结果。 绘图对于单变量表达式，在图像页面可以绘制其图像。 可以使用右侧按钮或鼠标滚轮放大缩小。拖动界面可移动绘图区域。 示例 1+(2*3-5^2)/4 sum((x%2==0)*x,1,10) diffi(x=&gt;abs(x),2) 绘图例子： x^3 diffi(x=&gt;abs(x),x) integ(x=&gt;e^(-x^2),0,x) 逻辑表达式运算符（优先级从低到高） -&gt; 推出 &lt;-&gt; 等价 | 或 ^ 异或 &amp; 且 ! 非 常量 true,True 真 false,False 假 求值在代值页面点击刷新会加载当前表达式所有有意义变量（部分变量可能会在计算中被化简掉），设置变量值后点击计算会在计算结果区显示结果。 数学表达式图像部分界面类似数学表达式部分的图像页面，但这里支持多个函数图像绘制。 解析器将会把每行解析为一个单变量函数，可以接受以下表达式 + 普通单变量表达式 `x^2` + 单变量 Lambda 表达式 `x=&gt;x^2` `x=&gt;func(return=x^2)` 这里的表达式解析基于下面将要提到的编程表达式，所以您可以使用丰富的编程函数构建复杂的函数。 左栏下方会显示所画的函数与颜色的对于关系，拖动右侧图像区域可以移动，支持滚轮缩放，但这会导致重新绘图，对于复杂函数可能需要等待绘图完成。 编程部分 此部分还不是很成熟，使用时请适当注意 支持数学表达式的代码式运算。点击上方按钮（或F5）即可运行，Esc键取消运行。如果有错误会在下方显示错误信息。 请使用如下语法（其中expr1,expr2,…是语句，注意用逗号分隔）： &gt; 此版本不再需要输入 `exec` 函数 123expr1,expr2,... 语句语法 赋值 12x=1,v=[1,2,3] 将指定名称变量赋值成右侧表达式的值，这里要求右侧表达式的值必须是能计算出确定值的表达式。 独立赋值12x:=1,v:=[1,2,3] 功能和赋值语句相同，但他会在当前环境新建变量，从而隐藏掉父级的同名变量。 弱声明1def(id,expr) 将指定名称的变量赋成右侧的表达式，这里不要求右侧表达式的值必须是常量（即可以是类似x^2这样的含变量表达式。 函数块1func(expr1,expr2,...) 函数块会自动新定义一个名为 return 的变量（初值为 Null ），函数块的结果为依次执行 expr 后 return 的值。 过程块1action(expr1,expr2,...) 过程块会依次执行 expr ，然后返回空值。 运行时函数1id=(v1,v2,...)=&gt;(expr) 构建一个运行时函数，其参数名为 v1,v2,... 。内部代码为 expr，结果为计算 expr 后的结果（这里可以用 func 构建 expr ）(这里运行时函数的本质就是一个 Lambda 表达式） 与赋值类似，def 也有相对应的 redef 独立声明 调用运行时函数 1id(args) 和调用预定义函数的用法相同。 以下用法已弃用call(fid,arg1,arg2,…) 程序控制函数 循环 1234for(begin,cond,step,expr)while(cond,expr)do(expr,cond)foreach(list,varName,expr) 条件 1if(cond,then-expr,else-expr) 更多函数 array(n,defaultVal) 生成 $n$ 个元素的元组，初始值为 defaultVal （可省略，默认为空值） range(l,r) 生成 $[l,r]$ 的整数序列 random(l,r) 生成 $[l,r)$ 范围内的随机整数 sort(list,cmpFunc) 升序排序，cmp 转换函数（Lambda 表达式） select(list,transFunc) where(list,condFunc) zip(list,zipFunc) 这几个函数和函数式编程中常用的三个同名函数意义相同，具体使用请参见 更多算法和例子 例子更多算法和例子请见 这里 基本计算1234567exec(list=[1,2,3],def(f,x^2),s=total(list),s,diff(f,@&quot;x&quot;)) 其结果为126(2*(x^1))*1 简单算法 快速幂计算模意义下的幂（模数较大且幂次较高时会有较大精度误差）123456789101112131415exec(mod=13331,def(qpow,(a,n), func( return=1, while(n&gt;=1, [ if(n%2==1,return=return*a%mod), a=a*a%mod, n=floor(n/2) ]) )),call(qpow,2,15)) 备注仍为测试版本，正在收集各式各样的Bug，已知Bug如下 绘图部分不稳定，尤其是复杂函数绘制和极大极小缩放场景 变量识别有漏洞 部分Bug将在下一版本中修复。 编程部分将有较大改动，将支持自定义函数：]]></content>
      <categories>
        <category>Designs</category>
      </categories>
      <tags>
        <tag>Apps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2FBlog%2F2017%2F12%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
